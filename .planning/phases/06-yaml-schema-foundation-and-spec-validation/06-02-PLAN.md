---
phase: 06-yaml-schema-foundation-and-spec-validation
plan: 02
type: tdd
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/data_architect/validation/__init__.py
  - src/data_architect/validation/loader.py
  - src/data_architect/validation/referential.py
  - src/data_architect/validation/errors.py
  - tests/test_validation.py
  - tests/fixtures/valid_spec.yaml
  - tests/fixtures/invalid_spec_bad_ref.yaml
  - tests/fixtures/invalid_spec_duplicate_mnemonic.yaml
autonomous: true

must_haves:
  truths:
    - "A valid YAML spec file loads into a frozen Spec model without error"
    - "An attribute referencing a nonexistent anchor produces a validation error citing the attribute name and the invalid anchor reference"
    - "A tie role referencing a nonexistent anchor/knot/nexus produces a clear error"
    - "Duplicate mnemonics across anchors/knots/nexuses produce a collision error naming both entities"
    - "Validation errors include the YAML line number where the problem occurs"
    - "Mnemonic auto-generation from descriptor is deterministic (sorted) with explicit override support"
    - "Attribute mnemonic uniqueness is enforced within each anchor and each nexus"
  artifacts:
    - path: "src/data_architect/validation/loader.py"
      provides: "YAML loading with line number capture using ruamel.yaml"
      contains: "def load_spec"
    - path: "src/data_architect/validation/referential.py"
      provides: "Referential integrity checks — anchor refs, knot refs, mnemonic uniqueness, tie composition"
      contains: "def check_referential_integrity"
    - path: "src/data_architect/validation/errors.py"
      provides: "Error formatting with line numbers merged from ruamel.yaml lc data"
      contains: "def format_errors"
    - path: "tests/test_validation.py"
      provides: "Tests for loading, referential integrity, line numbers, mnemonic collisions"
      min_lines: 120
    - path: "tests/fixtures/valid_spec.yaml"
      provides: "A valid YAML spec fixture for testing (subset of example.xml translated to YAML)"
    - path: "tests/fixtures/invalid_spec_bad_ref.yaml"
      provides: "Invalid spec with attribute referencing nonexistent anchor"
  key_links:
    - from: "src/data_architect/validation/loader.py"
      to: "src/data_architect/models/spec.py"
      via: "Spec.model_validate(data)"
      pattern: "Spec\\.model_validate"
    - from: "src/data_architect/validation/loader.py"
      to: "ruamel.yaml"
      via: "YAML().load() with lc line tracking"
      pattern: "from ruamel\\.yaml import YAML"
    - from: "src/data_architect/validation/referential.py"
      to: "src/data_architect/models/spec.py"
      via: "operates on Spec model checking cross-entity references"
      pattern: "def check_referential_integrity.*Spec"
    - from: "src/data_architect/validation/errors.py"
      to: "src/data_architect/validation/loader.py"
      via: "uses line_map from loader to enrich error messages"
      pattern: "line_map"
---

<objective>
Build a validation engine that loads YAML spec files into Pydantic models and reports referential integrity violations, mnemonic collisions, and structural errors with YAML line numbers.

Purpose: Users editing large YAML specs need precise error feedback to fix problems quickly. Line numbers bridge the gap between Pydantic field-path errors and the YAML file they're editing. Referential integrity catches broken cross-references before SQL generation.

Output: Validation module in `src/data_architect/validation/` with YAML fixtures and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-yaml-schema-foundation-and-spec-validation/06-RESEARCH.md
@.planning/phases/06-yaml-schema-foundation-and-spec-validation/06-01-SUMMARY.md
@.references/anchor/anchor.xsd
@.references/anchor/example.xml
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Define validation engine structure and failing tests</name>
  <files>
    src/data_architect/validation/__init__.py
    src/data_architect/validation/loader.py
    src/data_architect/validation/referential.py
    src/data_architect/validation/errors.py
    tests/test_validation.py
    tests/fixtures/valid_spec.yaml
    tests/fixtures/invalid_spec_bad_ref.yaml
    tests/fixtures/invalid_spec_duplicate_mnemonic.yaml
  </files>
  <action>
    1. Create `tests/fixtures/` directory.

    2. Create `tests/fixtures/valid_spec.yaml` — a valid YAML spec translating a subset of example.xml:
       ```yaml
       knot:
         - mnemonic: GEN
           descriptor: Gender
           identity: bit
           dataRange: "varchar(42)"
       anchor:
         - mnemonic: AC
           descriptor: Actor
           identity: int
           attribute:
             - mnemonic: NAM
               descriptor: Name
               timeRange: datetime
               dataRange: "varchar(42)"
             - mnemonic: GEN
               descriptor: Gender
               knotRange: GEN
       tie:
         - role:
             - role: subset
               type: AC
               identifier: false
             - role: of
               type: PN
               identifier: false
       ```
       Make it match the spec model structure from 06-01 (use list-based collections with aliases). Include enough entities to exercise referential integrity (at least 2 anchors, 1 knot, 1 tie referencing both).

    3. Create `tests/fixtures/invalid_spec_bad_ref.yaml` — an attribute with `knotRange: NONEXISTENT`.

    4. Create `tests/fixtures/invalid_spec_duplicate_mnemonic.yaml` — two anchors both with `mnemonic: AC`.

    5. Create `src/data_architect/validation/__init__.py` re-exporting: `load_spec`, `validate_spec`, `check_referential_integrity`, `ValidationResult`.

    6. Create `src/data_architect/validation/errors.py` with:
       - `@dataclass(frozen=True) ValidationError`: `field_path: str`, `message: str`, `line: int | None`, `severity: str = "error"`
       - `@dataclass(frozen=True) ValidationResult`: `spec: Spec | None`, `errors: list[ValidationError]`, `is_valid: bool` (property: len(errors) == 0)
       - `format_errors(errors: list[ValidationError]) -> str` — formats errors as "Line {N}: {message}" or "{field_path}: {message}" when no line available

    7. Create `src/data_architect/validation/loader.py` with:
       - `load_yaml_with_lines(yaml_path: Path) -> tuple[dict[str, Any], dict[str, int]]` — loads YAML using `ruamel.yaml.YAML()`, recursively captures lc.line for all nodes into a field_path -> line_number dict (0-based). Convert to 1-based when mapping.
       - `load_spec(yaml_path: Path) -> ValidationResult` — calls load_yaml_with_lines, then Spec.model_validate(data), catches ValidationError and maps field paths to line numbers using the line_map. Returns ValidationResult.
       - `validate_spec(yaml_path: Path) -> ValidationResult` — calls load_spec, then if valid, calls check_referential_integrity, merges errors. This is the full validation pipeline.

    8. Create `src/data_architect/validation/referential.py` with:
       - `check_referential_integrity(spec: Spec, line_map: dict[str, int]) -> list[ValidationError]` — checks:
         a. Every attribute knotRange references an existing knot mnemonic
         b. Every tie role type references an existing anchor, nexus, or knot mnemonic
         c. Every nexus role type references an existing anchor or knot mnemonic
         d. Global mnemonic uniqueness across anchors, nexuses, and knots (per anchor.xsd assertions)
         e. Attribute mnemonic uniqueness within each anchor and each nexus
         f. Each tie has at least 2 roles referencing anchors (per anchor.xsd assertion)
         g. Each nexus has at least 1 non-knot role (per anchor.xsd assertion)
         h. No two ties are identical in composition
       - For mnemonic collision detection: collect all (mnemonic, entity_type, entity_name) tuples, sorted by entity_name for deterministic ordering, report collisions with both entity names (SPEC-07)

    9. Write `tests/test_validation.py` with tests:
       - `test_load_valid_spec` — load valid_spec.yaml, expect is_valid=True, spec is not None
       - `test_load_invalid_yaml_syntax` — load malformed YAML, expect is_valid=False with parse error
       - `test_attribute_bad_knot_reference` — load invalid_spec_bad_ref.yaml, expect error mentioning "NONEXISTENT"
       - `test_duplicate_mnemonic_detection` — load invalid_spec_duplicate_mnemonic.yaml, expect error mentioning both entity names
       - `test_line_numbers_in_errors` — load invalid spec, expect at least one error with line != None
       - `test_tie_must_reference_two_anchors` — tie with only 1 anchor role produces error
       - `test_attribute_mnemonic_unique_per_anchor` — two attributes in same anchor with same mnemonic produces error
       - `test_mnemonic_collision_reports_both_entities` — error message contains both entity names
       - `test_valid_spec_returns_frozen_model` — loaded spec model is frozen
       - `test_format_errors_with_lines` — format_errors produces "Line N: message" format
       - `test_format_errors_without_lines` — format_errors produces "field_path: message" when no line

    10. Run tests to confirm RED state. Commit: `test(06-02): add failing tests for validation engine with line numbers`

    IMPORTANT: The line number mapping is the hardest part. ruamel.yaml's `lc` attribute is on CommentedMap/CommentedSeq objects. Build the line_map recursively during parse. For dict keys, use `obj.lc.key(key_name)` which returns (line, col) tuple. For list items, items of CommentedSeq have `lc` if they are themselves CommentedMap. Add +1 to convert 0-based to 1-based for user display.

    IMPORTANT: The referential integrity checks run AFTER Pydantic model_validate succeeds (they operate on the validated Spec model, not raw dicts). This is a second pass. Pydantic catches structural/type errors; referential.py catches semantic/cross-reference errors.

    IMPORTANT: Mnemonic collision detection must be deterministic — sort entities by name before checking to ensure consistent error ordering regardless of dict/YAML ordering (SPEC-07).
  </action>
  <verify>`uv run pytest tests/test_validation.py` -- tests MUST fail (RED state). All fixture YAML files exist in `tests/fixtures/`. `uv run ruff check src/data_architect/validation/` passes.</verify>
  <done>Validation module skeleton exists. Test fixtures exist. All validation tests fail (RED). Lint passes on new code.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement validation engine to pass all tests</name>
  <files>
    src/data_architect/validation/loader.py
    src/data_architect/validation/referential.py
    src/data_architect/validation/errors.py
    tests/test_validation.py
    tests/fixtures/valid_spec.yaml
  </files>
  <action>
    1. Implement `load_yaml_with_lines` in loader.py:
       - Use `from ruamel.yaml import YAML; yaml = YAML()` for YAML 1.2 parsing
       - Recursive `_capture_lines(obj, path, line_map)` that traverses CommentedMap and CommentedSeq
       - For CommentedMap: iterate keys, use `obj.lc.key(k)` to get (line, col), store in line_map as `f"{path}.{k}"` if path else `k` -> line (0-based, add 1 on output)
       - For CommentedSeq: iterate items, use `obj.lc.item(i)` for (line, col) of each list entry
       - Handle missing lc gracefully (some nodes may not have it)

    2. Implement `load_spec` in loader.py:
       - Load YAML, capture line_map
       - Try `Spec.model_validate(raw_data)`, catch `pydantic.ValidationError`
       - On Pydantic error: map each error's `loc` tuple to a field_path string, look up line in line_map, create ValidationError entries
       - On success: return ValidationResult with spec and empty errors

    3. Implement `validate_spec` in loader.py:
       - Call load_spec first
       - If load_spec failed (spec is None), return those errors
       - If load_spec succeeded, call `check_referential_integrity(spec, line_map)`
       - Merge any referential errors into result

    4. Implement `check_referential_integrity` in referential.py:
       - Build lookup sets: `anchor_mnemonics`, `knot_mnemonics`, `nexus_mnemonics`, `all_mnemonics`
       - Check knotRange references: for each anchor's attributes, if knotRange is set, verify it's in knot_mnemonics
       - Check tie role references: each role.type_ must be in anchor_mnemonics | nexus_mnemonics | knot_mnemonics
       - Check nexus role references: each role.type_ must be in anchor_mnemonics | knot_mnemonics
       - Check global mnemonic uniqueness: collect all (mnemonic -> list of "Type 'Name'"), report any with len > 1
       - Check attribute mnemonic uniqueness per anchor and per nexus
       - Check tie has >= 2 anchor roles
       - Check nexus has >= 1 non-knot role
       - Sort entities by name before processing for deterministic error ordering (SPEC-07)
       - For each violation, try to find line number from line_map

    5. Implement `format_errors` in errors.py:
       - Iterate errors, format as "Line {line}: {message}" if line is not None, else "{field_path}: {message}"
       - Join with newlines

    6. Adjust fixture YAML files if needed to match the actual model alias structure (the aliases from 06-01 determine whether YAML keys are "anchor" or "anchors", "attribute" or "attributes", etc.). The fixtures must match whatever the Pydantic model expects.

    7. Adjust tests if needed to match actual API behavior while still testing the same behaviors.

    8. Run `uv run pytest` (full suite) — all tests must pass. Run `make check` — full quality gate green.

    9. Commit: `feat(06-02): implement spec validation with line numbers and referential integrity`
  </action>
  <verify>`make check` passes. `uv run pytest tests/test_validation.py -v` shows all tests passing. Coverage >= 90%.</verify>
  <done>Valid specs load into frozen Spec models. Invalid specs produce line-numbered errors. Referential integrity violations (bad anchor refs, bad knot refs, duplicate mnemonics) are caught with clear messages naming both conflicting entities. Mnemonic detection is deterministic (sorted). Full quality gate green.</done>
</task>

</tasks>

<verification>
1. `uv run python -c "from data_architect.validation import validate_spec; print('validation imports OK')"` succeeds
2. `uv run pytest tests/test_validation.py -v` -- all tests pass
3. `make check` -- full quality gate green
4. Manual validation check: `uv run python -c "
from pathlib import Path
from data_architect.validation import validate_spec
result = validate_spec(Path('tests/fixtures/valid_spec.yaml'))
print(f'Valid: {result.is_valid}, Errors: {len(result.errors)}')
"` prints "Valid: True, Errors: 0"
5. Manual error check: `uv run python -c "
from pathlib import Path
from data_architect.validation import validate_spec
result = validate_spec(Path('tests/fixtures/invalid_spec_bad_ref.yaml'))
for e in result.errors: print(f'Line {e.line}: {e.message}')
"` prints line-numbered error about nonexistent reference
</verification>

<success_criteria>
- Valid YAML specs load into frozen Spec models without error
- Invalid specs produce ValidationResult with is_valid=False and specific error messages
- Referential integrity checks catch: bad anchor refs, bad knot refs, bad tie role refs, bad nexus role refs
- Mnemonic collision detection is deterministic and reports both conflicting entity names
- Attribute mnemonic uniqueness enforced per-anchor and per-nexus
- Tie composition checks (>= 2 anchor roles, no duplicate ties)
- Validation errors include YAML line numbers where available
- Error formatting produces human-readable "Line N: message" output
- All anchor.xsd assertions implemented as validation checks
- make check fully green with coverage >= 90%
</success_criteria>

<output>
After completion, create `.planning/phases/06-yaml-schema-foundation-and-spec-validation/06-02-SUMMARY.md`
</output>
