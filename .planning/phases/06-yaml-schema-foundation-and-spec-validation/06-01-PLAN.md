---
phase: 06-yaml-schema-foundation-and-spec-validation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/data_architect/models/__init__.py
  - src/data_architect/models/spec.py
  - src/data_architect/models/anchor.py
  - src/data_architect/models/tie.py
  - src/data_architect/models/knot.py
  - src/data_architect/models/common.py
  - tests/test_models.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "A valid YAML dict round-trips through Pydantic models without error"
    - "An invalid spec (missing required fields, wrong types) raises ValidationError"
    - "All models are frozen — mutation raises an error"
    - "XML-core, YAML-extension, and internal fields are distinguishable via metadata"
    - "The model structure matches anchor.xsd: anchors have attributes and identifiers, ties have roles, nexuses have roles and attributes, knots have mnemonic/descriptor/identity/dataRange"
    - "Attributes enforce exactly one of knotRange or dataRange (per anchor.xsd assertion)"
  artifacts:
    - path: "src/data_architect/models/spec.py"
      provides: "Top-level Spec model containing anchors, ties, knots, nexuses"
      contains: "class Spec"
    - path: "src/data_architect/models/anchor.py"
      provides: "Anchor, Attribute, Identifier models"
      contains: "class Anchor"
    - path: "src/data_architect/models/tie.py"
      provides: "Tie and Role models"
      contains: "class Tie"
    - path: "src/data_architect/models/knot.py"
      provides: "Knot model"
      contains: "class Knot"
    - path: "src/data_architect/models/common.py"
      provides: "Key, SchemaLayer enum, base config, construct fields (metadata, layout, description)"
      contains: "class SchemaLayer"
    - path: "tests/test_models.py"
      provides: "Tests for all models: construction, frozen, layer tagging, xsd assertions"
      min_lines: 100
  key_links:
    - from: "src/data_architect/models/spec.py"
      to: "src/data_architect/models/anchor.py"
      via: "import Anchor, Attribute"
      pattern: "from data_architect\\.models\\.anchor import"
    - from: "src/data_architect/models/spec.py"
      to: "src/data_architect/models/tie.py"
      via: "import Tie, Role"
      pattern: "from data_architect\\.models\\.tie import"
    - from: "src/data_architect/models/spec.py"
      to: "src/data_architect/models/knot.py"
      via: "import Knot"
      pattern: "from data_architect\\.models\\.knot import"
    - from: "src/data_architect/models/anchor.py"
      to: "src/data_architect/models/common.py"
      via: "import SchemaLayer, Key"
      pattern: "from data_architect\\.models\\.common import"
---

<objective>
Define Pydantic v2 frozen models that represent the full Anchor Modeling specification as a YAML superset of anchor.xsd, with three-layer schema metadata for XML interoperability.

Purpose: These models are the core data structure consumed by every downstream feature (validation, SQL generation, import/export, CLI). Getting them right means everything else composes cleanly.

Output: Pydantic models in `src/data_architect/models/` with full test coverage, plus pydantic and ruamel.yaml added as dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-yaml-schema-foundation-and-spec-validation/06-RESEARCH.md
@.references/anchor/anchor.xsd
@.references/anchor/example.xml
@src/data_architect/scaffold.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Define Pydantic model structure and failing tests</name>
  <files>
    src/data_architect/models/__init__.py
    src/data_architect/models/common.py
    src/data_architect/models/anchor.py
    src/data_architect/models/tie.py
    src/data_architect/models/knot.py
    src/data_architect/models/spec.py
    tests/test_models.py
    pyproject.toml
  </files>
  <action>
    1. Add runtime dependencies to pyproject.toml: `pydantic>=2.10.0` and `ruamel.yaml>=0.18.0`. Run `uv sync` to install.

    2. Create `src/data_architect/models/` package.

    3. Create `src/data_architect/models/common.py` with:
       - `SchemaLayer` enum: `XML_CORE`, `YAML_EXT`, `INTERNAL` (for three-layer tagging per SPEC-06)
       - Helper function `xml_field(...)`, `yaml_ext_field(...)`, `internal_field(...)` that return `pydantic.Field(...)` with `json_schema_extra={"layer": "xml-core"|"yaml-ext"|"internal"}` metadata. Use `json_schema_extra` because Pydantic v2 `Field.metadata` is a list, not dict — `json_schema_extra` is the standard way to attach custom schema metadata that can be inspected at runtime via `model_fields[name].json_schema_extra`.
       - `Key` frozen Pydantic model: `stop: str`, `route: str`, `of_: str` (Field alias "of"), `branch: str = "1"` — all xml-core. Matches anchor.xsd `<key>` element.
       - `Identifier` frozen Pydantic model: `route: str` — xml-core. Matches anchor.xsd `<identifier>`.
       - Base config constant: `FROZEN_CONFIG = ConfigDict(frozen=True, populate_by_name=True)` for all models.

    4. Create `src/data_architect/models/knot.py` with frozen `Knot` model:
       - xml-core fields: `mnemonic: str`, `descriptor: str`, `identity: str`, `data_range: str` (Field alias "dataRange")
       - yaml-ext fields: (none for now, placeholder for future extensions)
       - internal fields: (none for now)
       - Optional construct fields (xml-core): `metadata_: dict[str, Any] | None = None` (alias "metadata"), `layout: Any | None = None`, `description_: str | None = None` (alias "description")

    5. Create `src/data_architect/models/anchor.py` with frozen models:
       - `Attribute` model:
         - xml-core: `mnemonic: str`, `descriptor: str`, `knot_range: str | None = None` (alias "knotRange"), `data_range: str | None = None` (alias "dataRange"), `time_range: str | None = None` (alias "timeRange"), `keys: list[Key] = []` (alias "key"), construct fields
         - yaml-ext: `staging_column: str | None = None`
         - `@model_validator(mode='after')` enforcing exactly one of knotRange/dataRange (per anchor.xsd assert `count(@knotRange) + count(@dataRange) = 1`)
       - `Anchor` model:
         - xml-core: `mnemonic: str`, `descriptor: str`, `identity: str`, `attributes: list[Attribute] = []` (alias "attribute"), `identifiers: list[Identifier] = []` (alias "identifier"), construct fields
         - yaml-ext: `staging_mappings: list[Any] = []` (placeholder for Phase 8 STG-01)

    6. Create `src/data_architect/models/tie.py` with frozen models:
       - `Role` model:
         - xml-core: `role: str`, `type_: str` (alias "type"), `identifier: bool = False`, `coloring: str | None = None`, `keys: list[Key] = []` (alias "key"), construct fields
       - `Tie` model:
         - xml-core: `roles: list[Role]` (alias "role"), `time_range: str | None = None` (alias "timeRange"), construct fields

    7. Create `src/data_architect/models/spec.py` with:
       - `Nexus` model:
         - xml-core: `mnemonic: str`, `descriptor: str`, `identity: str`, `attributes: list[Attribute] = []`, `roles: list[Role] = []`, `identifiers: list[Identifier] = []`, construct fields
       - `Spec` model (top-level):
         - `anchors: list[Anchor] = []` (alias "anchor")
         - `knots: list[Knot] = []` (alias "knot")
         - `ties: list[Tie] = []` (alias "tie")
         - `nexuses: list[Nexus] = []` (alias "nexus")
         - construct fields (metadata, layout, description)

    8. Create `src/data_architect/models/__init__.py` re-exporting all public types: Spec, Anchor, Attribute, Tie, Role, Knot, Nexus, Key, Identifier, SchemaLayer.

    9. Write `tests/test_models.py` with failing tests:
       - `test_spec_from_valid_dict` — construct Spec from dict matching example.xml structure, expect success
       - `test_anchor_requires_mnemonic` — missing mnemonic raises ValidationError
       - `test_attribute_requires_exactly_one_range` — attribute with both knotRange and dataRange raises error; attribute with neither raises error
       - `test_models_are_frozen` — assigning to anchor.mnemonic raises ValidationError
       - `test_model_copy_works` — anchor.model_copy(update={"descriptor": "New"}) succeeds
       - `test_schema_layer_tagging` — inspect Anchor.model_fields["mnemonic"].json_schema_extra["layer"] == "xml-core", Anchor.model_fields["staging_mappings"].json_schema_extra["layer"] == "yaml-ext"
       - `test_knot_construction` — Knot from valid dict succeeds
       - `test_tie_with_roles` — Tie with list of roles from valid dict succeeds
       - `test_nexus_construction` — Nexus from valid dict succeeds
       - `test_key_alias_of` — Key(stop="1", route="1st", **{"of": "ST"}) works via alias
       - `test_attribute_data_range_only` — Attribute with only dataRange succeeds
       - `test_attribute_knot_range_only` — Attribute with only knotRange succeeds

    10. Run tests to confirm RED state (tests fail because models may have import issues or incomplete construction). Commit: `test(06-01): add failing tests for spec Pydantic models`

    IMPORTANT: The project constraint is "pure functional style, no classes" for behavior — but Pydantic models ARE data classes (not behavior classes). This is the same pattern as frozen dataclasses already used in scaffold.py. Models define data shape; functions operate on them.

    IMPORTANT: Use Typer (already in the project), NOT Click. The research suggested Click but the codebase already uses Typer. Continue with Typer.

    IMPORTANT: Use `pydantic>=2.10.0` not `>=2.12.5` — PyPI shows 2.10 as a stable recent version. The research version may not exist yet. Check `uv add pydantic` output and use whatever stable version resolves.
  </action>
  <verify>`uv run pytest tests/test_models.py` -- tests MUST fail (RED state). `uv run ruff check src/data_architect/models/` must pass (no lint errors in model definitions).</verify>
  <done>All test files exist, all model files exist with correct structure, tests fail because implementation is intentionally incomplete or tests exercise behaviors not yet wired. RED commit created.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement models to pass all tests</name>
  <files>
    src/data_architect/models/common.py
    src/data_architect/models/anchor.py
    src/data_architect/models/tie.py
    src/data_architect/models/knot.py
    src/data_architect/models/spec.py
    tests/test_models.py
  </files>
  <action>
    1. Fix any issues in model definitions to make all tests pass. Expected areas:
       - Ensure `model_config = FROZEN_CONFIG` is set on every model
       - Ensure `populate_by_name=True` is in ConfigDict so both Python names and aliases work
       - Ensure the `@model_validator(mode='after')` on Attribute correctly enforces exactly-one-of knotRange/dataRange
       - Ensure all Field aliases are correct (e.g., `Field(alias="dataRange")`)
       - Ensure `json_schema_extra` layer tagging works as expected

    2. If any test needs adjustment to match actual Pydantic v2 API behavior (e.g., error types), fix the test to be correct while still testing the same behavior.

    3. Run `uv run pytest` (full suite) to ensure new models don't break existing tests. Coverage must stay above 90%.

    4. Run `make check` to verify lint + type + test all pass.

    5. Commit: `feat(06-01): implement frozen Pydantic spec models with three-layer schema`
  </action>
  <verify>`make check` passes (lint + type + test). `uv run pytest tests/test_models.py -v` shows all tests passing. Coverage >= 90%.</verify>
  <done>All model tests pass. Spec, Anchor, Attribute, Tie, Role, Knot, Nexus, Key, Identifier models are frozen, properly aliased, and three-layer tagged. Full quality gate green.</done>
</task>

</tasks>

<verification>
1. `uv run python -c "from data_architect.models import Spec, Anchor, Attribute, Tie, Role, Knot, Nexus, Key, Identifier, SchemaLayer; print('All imports OK')"` succeeds
2. `uv run pytest tests/test_models.py -v` -- all tests pass
3. `make check` -- full quality gate green
4. Model frozen check: `uv run python -c "from data_architect.models import Anchor; a = Anchor(mnemonic='AC', descriptor='Customer', identity='int'); a.mnemonic = 'XX'"` raises error
5. Layer tagging check: `uv run python -c "from data_architect.models import Anchor; print(Anchor.model_fields['mnemonic'].json_schema_extra)"` prints dict with layer key
</verification>

<success_criteria>
- All Pydantic models are frozen and immutable
- Three-layer schema metadata (xml-core, yaml-ext, internal) is inspectable on every field
- Attribute enforces exactly-one-of knotRange/dataRange
- All anchor.xsd constructs mapped: anchor, attribute, tie, role, knot, nexus, key, identifier
- YAML extension fields (staging_mappings, staging_column) exist as placeholders
- Tests cover construction, validation, frozen enforcement, layer tagging
- pydantic and ruamel.yaml added to project dependencies
- make check fully green
</success_criteria>

<output>
After completion, create `.planning/phases/06-yaml-schema-foundation-and-spec-validation/06-01-SUMMARY.md`
</output>
