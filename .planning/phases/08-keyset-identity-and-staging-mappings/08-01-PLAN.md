---
phase: 08-keyset-identity-and-staging-mappings
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/data_architect/identity/__init__.py
  - src/data_architect/identity/keyset.py
  - src/data_architect/identity/escaping.py
  - tests/test_keyset.py
autonomous: true

must_haves:
  truths:
    - "format_keyset() produces the canonical keyset string 'entity@system~tenant|natural_key'"
    - "parse_keyset() returns a KeysetComponents named tuple with entity, system, tenant, natural_key fields"
    - "Round-trip parse(format(entity, system, tenant, nk)) == (entity, system, tenant, nk) for all string inputs including delimiter-heavy strings"
    - "NULL natural key produces NULL keyset (None return from format_keyset)"
    - "Delimiter characters in any component are escaped: @ -> @@, ~ -> ~~, | -> ||"
    - "parse_keyset never raises an exception on any string input"
  artifacts:
    - path: "src/data_architect/identity/__init__.py"
      provides: "Public API re-exports: parse_keyset, format_keyset, KeysetComponents"
      exports: ["parse_keyset", "format_keyset", "KeysetComponents"]
    - path: "src/data_architect/identity/keyset.py"
      provides: "KeysetComponents NamedTuple, parse_keyset, format_keyset functions"
      contains: "KeysetComponents"
    - path: "src/data_architect/identity/escaping.py"
      provides: "escape_delimiters, unescape_delimiters pure functions"
      exports: ["escape_delimiters", "unescape_delimiters"]
    - path: "tests/test_keyset.py"
      provides: "Hypothesis property-based tests + unit tests for keyset module"
      contains: "@given"
  key_links:
    - from: "src/data_architect/identity/keyset.py"
      to: "src/data_architect/identity/escaping.py"
      via: "import escape_delimiters, unescape_delimiters"
      pattern: "from data_architect\\.identity\\.escaping import"
---

<objective>
KeysetIdentity module with parse/format functions, delimiter escaping, NULL safety, and Hypothesis property-based tests

Purpose: Implement the keyset identity encoding scheme (`entity@system~tenant|natural_key`) that enables multi-source data provenance tracking. This is the foundational building block for staging mappings and multi-source loading SQL.

Output: A tested `data_architect.identity` module with `parse_keyset()`, `format_keyset()`, and delimiter escaping utilities. Property-based tests verify round-trip correctness for all string inputs including delimiter-heavy and adversarial cases.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-keyset-identity-and-staging-mappings/08-RESEARCH.md
</context>

<feature>
  <name>KeysetIdentity Parse/Format with Hypothesis Round-Trip Tests</name>
  <files>
    src/data_architect/identity/__init__.py
    src/data_architect/identity/escaping.py
    src/data_architect/identity/keyset.py
    tests/test_keyset.py
  </files>
  <behavior>
    Keyset format: `entity@system~tenant|natural_key`
    Delimiter escaping: `@` -> `@@`, `~` -> `~~`, `|` -> `||` (applied to all components)
    Unescape: reverse of escape (replace doubled delimiters with singles)

    **format_keyset(entity, system, tenant, natural_key) -> str | None:**
    - If natural_key is None, return None (KEY-05 null safety)
    - Entity, system, tenant must be non-empty strings (raise ValueError if empty)
    - Escape all components, then join: `{esc_entity}@{esc_system}~{esc_tenant}|{esc_nk}`
    - Empty natural_key string is valid (produces `entity@system~tenant|`)

    **parse_keyset(s: str) -> KeysetComponents | None:**
    - If s is None or empty, return None
    - Split on UNESCAPED delimiters (scan character by character, not naive split)
    - Return None for malformed inputs (wrong number of segments)
    - Return KeysetComponents(entity, system, tenant, natural_key) with unescaped values

    **KeysetComponents:** NamedTuple with fields: entity, system, tenant, natural_key

    **Escaping module (escaping.py):**
    - escape_delimiters(s: str) -> str: @ -> @@, ~ -> ~~, | -> ||
    - unescape_delimiters(s: str) -> str: @@ -> @, ~~ -> ~, || -> |
    - CRITICAL: escape order is @ then ~ then | (does not matter for escape, but for unescape you must use a sentinel/placeholder approach to avoid double-replacement issues with inputs like "@@")

    Cases:
    - format_keyset("Customer", "Northwind", "ACME", "10248") -> "Customer@Northwind~ACME|10248"
    - format_keyset("Customer", "Northwind", "ACME", None) -> None (KEY-05)
    - format_keyset("Order", "SAP@US", "Corp~Ltd", "A|B") -> "Order@SAP@@US~Corp~~Ltd|A||B"
    - parse_keyset("Customer@Northwind~ACME|10248") -> KeysetComponents("Customer", "Northwind", "ACME", "10248")
    - parse_keyset("Order@SAP@@US~Corp~~Ltd|A||B") -> KeysetComponents("Order", "SAP@US", "Corp~Ltd", "A|B")
    - parse_keyset("garbage") -> None
    - parse_keyset("") -> None
    - parse_keyset(None) -> None (type: str | None parameter)
  </behavior>
  <implementation>
    **escaping.py:**
    - escape_delimiters: simple chained .replace("@", "@@").replace("~", "~~").replace("|", "||")
    - unescape_delimiters: MUST use a placeholder/sentinel approach. Naive .replace("@@", "@") fails for inputs like "@@@@" (which should become "@@"). Use a unique sentinel string (e.g., "\x00DELIM_AT\x00") to temporarily replace escaped sequences, then restore:
      1. Replace "@@" with sentinel_at
      2. Replace "~~" with sentinel_tilde
      3. Replace "||" with sentinel_pipe
      4. Return result (sentinels are now the unescaped chars)
      Actually simpler: since after escape, delimiters are always doubled, unescape can use .replace("@@", "@").replace("~~", "~").replace("||", "|") IF the input was produced by escape_delimiters. But parse_keyset splits on unescaped delimiters first, then unescapes each segment, so the segment will never contain unescaped delimiters. This means naive replace works for unescaping segments.

    **keyset.py:**
    - KeysetComponents = NamedTuple with entity, system, tenant, natural_key fields
    - format_keyset: check null, check non-empty, escape all components, join with delimiters
    - parse_keyset: scan input character by character to find unescaped `@`, `~`, `|` positions. An unescaped delimiter is one NOT preceded by the same character (check for odd/even runs). Split into 4 segments, unescape each, return KeysetComponents. Return None if not exactly 3 delimiters found in correct order (@, ~, |).

    **Parsing algorithm for splitting on unescaped delimiters:**
    The parser must find the FIRST unescaped `@`, then the FIRST unescaped `~` after that, then the FIRST unescaped `|` after that. An "unescaped" delimiter is one that is not part of a `@@`, `~~`, or `||` pair. Scan left to right: when encountering a delimiter char, check if the next char is the same (if so, skip both as escaped pair). Otherwise, it's an unescaped delimiter marking a segment boundary.

    **__init__.py:**
    Re-export parse_keyset, format_keyset, KeysetComponents from keyset module, and escape_delimiters, unescape_delimiters from escaping module.

    **Hypothesis test strategy:**
    - Round-trip: @given(entity=st.text(min_size=1), system=st.text(min_size=1), tenant=st.text(min_size=1), natural_key=st.text()) -> format then parse, assert equality
    - Delimiter-heavy: use st.text(alphabet=st.characters(whitelist_characters="@~|abc123"))
    - Crash safety: @given(st.text()) -> parse_keyset never raises
    - NULL propagation: format_keyset(entity, system, tenant, None) is None
    - Explicit unit tests for the documented cases above
  </implementation>
</feature>

<verification>
```bash
# Run keyset tests specifically
python -m pytest tests/test_keyset.py -v

# Run full suite
make check

# Verify Hypothesis finds no counterexamples
python -m pytest tests/test_keyset.py -v --hypothesis-show-statistics
```
</verification>

<success_criteria>
- KeysetComponents NamedTuple, parse_keyset, format_keyset exported from data_architect.identity
- escape_delimiters and unescape_delimiters exported from data_architect.identity
- Hypothesis round-trip test passes with @given(st.text()) for all 4 components
- Delimiter-heavy round-trip test passes (inputs with @, ~, | characters)
- parse_keyset never raises on any string input (crash safety test)
- NULL natural key -> None return (KEY-05)
- Empty entity/system/tenant -> ValueError
- All explicit test cases pass
- make check passes (lint + type + test)
- Coverage >= 95% for identity module
</success_criteria>

<output>
After completion, create `.planning/phases/08-keyset-identity-and-staging-mappings/08-01-SUMMARY.md`
</output>
