---
phase: 09-xml-interoperability
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/data_architect/xml_interop/export_xml.py
  - src/data_architect/xml_interop/validation.py
  - src/data_architect/xml_interop/roundtrip.py
  - src/data_architect/xml_interop/__init__.py
  - src/data_architect/cli.py
  - tests/test_xml_export.py
  - tests/test_xml_roundtrip.py
autonomous: true

must_haves:
  truths:
    - "A YAML spec exports to XML that passes lxml XSD validation against anchor.xsd"
    - "Export warns the user about YAML-only extensions (staging_mappings, staging_column, keyset identity) being dropped"
    - "Export requires --force to proceed when YAML-only extensions are present"
    - "Export without extensions present does not require --force"
    - "An XML file imported to YAML and exported back to XML produces semantically equivalent XML for the XML-compatible core"
    - "Round-trip comparison uses C14N canonicalization to ignore attribute order and whitespace differences"
  artifacts:
    - path: "src/data_architect/xml_interop/export_xml.py"
      provides: "YAML Spec to XML conversion with extension checking"
      exports: ["export_spec_to_xml", "check_yaml_extensions"]
    - path: "src/data_architect/xml_interop/validation.py"
      provides: "XSD validation against anchor.xsd"
      exports: ["validate_xml_against_xsd"]
    - path: "src/data_architect/xml_interop/roundtrip.py"
      provides: "C14N canonicalization and round-trip equivalence checking"
      exports: ["canonicalize_xml", "assert_roundtrip_equivalent"]
    - path: "tests/test_xml_export.py"
      provides: "Export tests including extension warnings and XSD validation"
      min_lines: 100
    - path: "tests/test_xml_roundtrip.py"
      provides: "Round-trip tests with example.xml and synthetic specs"
      min_lines: 60
  key_links:
    - from: "src/data_architect/xml_interop/export_xml.py"
      to: "src/data_architect/xml_interop/models.py"
      via: "from_yaml_model() class methods on XML models"
      pattern: "from_yaml_model"
    - from: "src/data_architect/xml_interop/export_xml.py"
      to: "src/data_architect/xml_interop/validation.py"
      via: "validate_xml_against_xsd() called after serialization"
      pattern: "validate_xml_against_xsd"
    - from: "src/data_architect/xml_interop/roundtrip.py"
      to: "src/data_architect/xml_interop/import_xml.py"
      via: "import + export pipeline for round-trip"
      pattern: "import_xml_string_to_spec"
    - from: "src/data_architect/cli.py"
      to: "src/data_architect/xml_interop/export_xml.py"
      via: "dab export command calling export_spec_to_xml"
      pattern: "export_spec_to_xml"
---

<objective>
Export YAML specs to valid Anchor XML with extension warnings, XSD validation, and round-trip verification (INTOP-02, INTOP-03, INTOP-04).

Purpose: Users can export their YAML specs back to official Anchor Modeler XML format for use in the Anchor Modeler tool. The export warns about data loss (YAML-only extensions like staging mappings and keyset identity are not representable in XML). Round-trip validation proves the conversion is lossless for the XML-compatible core.

Output: Export function, XSD validator, round-trip utilities, CLI `dab export` command, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-xml-interoperability/09-RESEARCH.md
@.planning/phases/09-xml-interoperability/09-01-SUMMARY.md
@.references/anchor/anchor.xsd
@.references/anchor/example.xml
@src/data_architect/models/common.py
@src/data_architect/models/spec.py
@src/data_architect/models/anchor.py
@src/data_architect/xml_interop/models.py
@src/data_architect/xml_interop/import_xml.py
@src/data_architect/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export function, XSD validation, and extension warnings</name>
  <files>
    src/data_architect/xml_interop/export_xml.py
    src/data_architect/xml_interop/validation.py
    src/data_architect/xml_interop/roundtrip.py
    src/data_architect/xml_interop/__init__.py
    src/data_architect/xml_interop/models.py
  </files>
  <action>
**Step 1: Add `from_yaml_model()` class methods to XML models in `models.py`.**

Each XML model class (created in Plan 01) needs a `@classmethod from_yaml_model(cls, model)` that converts from the existing Pydantic BaseModel to the pydantic-xml BaseXmlModel. These are the inverse of `to_yaml_model()`.

For each model:
- `KeyXML.from_yaml_model(key: Key)` -- map stop, route, of_, branch
- `IdentifierXML.from_yaml_model(id: Identifier)` -- map route
- `AttributeXML.from_yaml_model(attr: Attribute)` -- map mnemonic, descriptor, knotRange/dataRange, timeRange, keys. EXCLUDE staging_column (YAML-extension field)
- `RoleXML.from_yaml_model(role: Role)` -- map role, type_, identifier, coloring, keys
- `AnchorXML.from_yaml_model(anchor: Anchor)` -- map mnemonic, descriptor, identity, attributes, identifiers. EXCLUDE staging_mappings (YAML-extension field)
- `KnotXML.from_yaml_model(knot: Knot)` -- map all fields (knots have no YAML extensions)
- `TieXML.from_yaml_model(tie: Tie)` -- map timeRange, roles
- `NexusXML.from_yaml_model(nexus: Nexus)` -- map mnemonic, descriptor, identity, attributes, roles, identifiers
- `SchemaXML.from_yaml_model(spec: Spec)` -- map anchors, knots, ties, nexuses

For metadata and description fields: if the YAML model has metadata_ or description_ set, convert them to the XML model equivalents. For metadata (dict), this may require special handling since pydantic-xml needs to serialize arbitrary attributes. If too complex, omit metadata from export (it's rarely user-authored in YAML) and document the limitation.

For layout: if present in YAML model, preserve as-is during export. If layout is stored as opaque data, convert back appropriately.

**Step 2: Create `src/data_architect/xml_interop/export_xml.py`.**

Two main functions:

```python
def check_yaml_extensions(spec: Spec) -> list[str]:
    """Return list of YAML-extension fields present in spec.

    Checks for:
    - staging_mappings on any anchor (non-empty list)
    - staging_column on any attribute (non-None)
    Returns human-readable descriptions like:
    - "Anchor 'OR' has 2 staging mappings"
    - "Attribute 'OR.NAM' has staging_column mapping"
    """

def export_spec_to_xml(spec: Spec, *, force: bool = False) -> str:
    """Export YAML Spec to Anchor Modeler XML string.

    Steps:
    1. Check for YAML extensions -- if present and not force, raise ValueError
       with list of extensions that would be dropped
    2. Convert Spec to SchemaXML via from_yaml_model()
    3. Serialize SchemaXML to XML bytes using .to_xml()
    4. Add namespace declaration: the exported XML MUST include
       xmlns="http://anchormodeling.com/schema" on the root <schema> element
       for Anchor Modeler compatibility
    5. Validate against anchor.xsd using validate_xml_against_xsd()
    6. Pretty-print the XML using lxml etree.tostring(pretty_print=True)
    7. Return the XML string with XML declaration (<?xml version="1.0"?>)

    Raises:
        ValueError: If YAML extensions present and force=False
        ValueError: If generated XML fails XSD validation
    """
```

For the namespace on export: Even though import strips namespaces for easier parsing, export MUST add the namespace back. Strategy:
- Option A: Configure SchemaXML with `nsmap={"": "http://anchormodeling.com/schema"}` for export only (may require a separate export-specific model or dynamic nsmap)
- Option B: After serialization, use lxml to add the namespace to the root element
- Option B is simpler and more reliable. After pydantic-xml serializes to bytes, parse with lxml, set the root element's namespace, re-serialize.

```python
def _add_namespace(xml_bytes: bytes) -> bytes:
    """Add Anchor Modeling namespace to root element."""
    from lxml import etree
    NS = "http://anchormodeling.com/schema"
    doc = etree.fromstring(xml_bytes)
    # Set namespace on root and all descendant elements
    for elem in doc.iter():
        elem.tag = f"{{{NS}}}{elem.tag}" if '}' not in elem.tag else elem.tag
    return etree.tostring(doc, xml_declaration=True, encoding="UTF-8", pretty_print=True)
```

IMPORTANT: anchor.xsd assertions (lines 93, 138-155) use XPath 2.0 features (`xs:assert`). lxml's XMLSchema validates XSD 1.0 and may NOT support these assertions. Research note confirms this concern. Test the validation -- if lxml cannot validate because of assertions, either:
- Use a custom XSD copy with assertions removed (placed in the project, not modifying .references/)
- Skip assertion validation in lxml and note the limitation
- Implement key assertions in Python code

The pragmatic approach: Try lxml validation first. If it fails on assertions, create a `_VALIDATION_XSD` that strips the `xs:assert` elements (in Python at load time, not modifying the file). Document this limitation.

**Step 3: Create `src/data_architect/xml_interop/validation.py`.**

```python
def validate_xml_against_xsd(xml_bytes: bytes) -> tuple[bool, list[str]]:
    """Validate XML bytes against anchor.xsd.

    Loads XSD from .references/anchor/anchor.xsd (cached at module level).
    Returns (is_valid, error_messages).

    Error messages include line and column numbers from lxml.
    """
```

Implementation:
- Locate anchor.xsd relative to the package. Use `importlib.resources` or `Path(__file__).parent.parent.parent.parent / ".references" / "anchor" / "anchor.xsd"`. Better: accept the XSD path as parameter with a default, or use a module-level constant.
- Since this is a CLI tool (not a library), using a path relative to project root is acceptable. The XSD path can be discovered at runtime: check for `.references/anchor/anchor.xsd` relative to the package install location or relative to cwd.
- BEST approach: Bundle anchor.xsd as package data. Add it to `src/data_architect/xml_interop/anchor.xsd` (copy from .references/) or reference it from .references/. For now, use Path resolution from the module file location since this is a development tool.
- Cache the compiled XMLSchema at module level for performance (Research pitfall #5).
- If XSD compilation fails due to xs:assert elements, create a preprocessed version at runtime that strips them.

**Step 4: Create `src/data_architect/xml_interop/roundtrip.py`.**

```python
def canonicalize_xml(xml_string: str) -> bytes:
    """Canonicalize XML using C14N for semantic comparison.

    Normalizes attribute order, whitespace, namespace prefixes.
    """

def assert_roundtrip_equivalent(original_xml: str, roundtrip_xml: str) -> None:
    """Assert two XML strings are semantically equivalent.

    Uses C14N canonicalization. Raises AssertionError with details if not equivalent.
    """
```

Implementation uses `lxml.etree.tostring(doc, method='c14n2')` (C14N 2.0) or `method='c14n'` (C14N 1.0). C14N handles attribute order normalization, whitespace normalization, and namespace prefix normalization.

NOTE: C14N comparison must account for the fact that original XML may lack namespace while exported XML has namespace. For round-trip comparison, compare the NON-namespaced canonical forms (strip namespace from both before canonicalization) since the goal is semantic equivalence of the core content, not byte-identical XML.

**Step 5: Update `src/data_architect/xml_interop/__init__.py`.**

Add new exports:
```python
from data_architect.xml_interop.export_xml import export_spec_to_xml, check_yaml_extensions
from data_architect.xml_interop.validation import validate_xml_against_xsd
from data_architect.xml_interop.roundtrip import canonicalize_xml, assert_roundtrip_equivalent
```
  </action>
  <verify>
Run `python -c "from data_architect.xml_interop import export_spec_to_xml, validate_xml_against_xsd, canonicalize_xml; print('OK')"` to verify imports. Create a simple Spec in Python and export it: verify XML string output contains namespace and XML declaration.
  </verify>
  <done>
`export_spec_to_xml()` converts Spec to valid Anchor XML with namespace. `check_yaml_extensions()` detects YAML-only fields. `validate_xml_against_xsd()` validates against anchor.xsd. `canonicalize_xml()` and `assert_roundtrip_equivalent()` support round-trip comparison.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI export command and comprehensive tests</name>
  <files>
    src/data_architect/cli.py
    tests/test_xml_export.py
    tests/test_xml_roundtrip.py
  </files>
  <action>
**Step 1: Add `dab export` command to `src/data_architect/cli.py`.**

Add imports:
```python
from data_architect.xml_interop import export_spec_to_xml, check_yaml_extensions
```

Add command:
```python
@dab_app.command(name="export")
def dab_export(
    spec_path: Path = typer.Argument(..., help="Path to YAML spec file"),
    output: Path = typer.Option(
        Path("model.xml"),
        "--output", "-o",
        help="Output XML file",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        help="Force export, dropping YAML-only extensions",
    ),
    overwrite: bool = typer.Option(
        False,
        "--overwrite",
        help="Overwrite existing XML file",
    ),
) -> None:
```

Implementation flow:
1. Validate spec_path exists, exit(1) with red error if not
2. Load and validate spec using `validate_spec(spec_path)`, exit(1) with errors if invalid
3. Check output exists and not --overwrite, exit(1) with red error
4. Check for YAML extensions: if extensions found and not --force, print yellow warning listing each extension that would be dropped, print "Use --force to proceed", exit(1)
5. Call `export_spec_to_xml(result.spec, force=force)` -- catch ValueError (XSD validation failure), print red error, exit(1)
6. Write XML to output file
7. Print green success: checkmark + "Exported {spec_path} -> {output}"

The warning output should list specific extensions clearly:
```
Warning: YAML-only extensions will be dropped:
  - Anchor 'OR': 2 staging mappings
  - Attribute 'OR.NAM': staging_column 'order_name'
Use --force to proceed with export.
```

**Step 2: Create `tests/test_xml_export.py`.**

Test categories:

A. **Extension detection tests:**
- `test_check_no_extensions()` -- spec with no YAML extensions returns empty list
- `test_check_staging_mappings_detected()` -- anchor with staging_mappings returns warning
- `test_check_staging_column_detected()` -- attribute with staging_column returns warning
- `test_check_multiple_extensions()` -- spec with both types returns all warnings

B. **Export function tests:**
- `test_export_simple_spec()` -- export minimal spec (one anchor, one attribute), verify XML output contains `<schema`, `<anchor`, `<attribute` elements
- `test_export_includes_namespace()` -- verify `xmlns="http://anchormodeling.com/schema"` on root element
- `test_export_includes_xml_declaration()` -- verify `<?xml` at start
- `test_export_knots_ties_nexuses()` -- export spec with all entity types, verify all present in XML
- `test_export_preserves_timerange()` -- historized attribute and tie export correctly
- `test_export_preserves_keys()` -- key elements with stop/route/of/branch
- `test_export_preserves_identifiers()` -- identifier elements on anchors/nexuses
- `test_export_raises_without_force()` -- spec with staging_mappings, no --force, raises ValueError
- `test_export_succeeds_with_force()` -- spec with staging_mappings, --force=True, succeeds
- `test_export_no_force_needed_without_extensions()` -- spec without extensions, force=False, succeeds

C. **XSD validation tests:**
- `test_validate_valid_xml()` -- valid Anchor XML passes validation
- `test_validate_invalid_xml()` -- missing required attribute fails validation
- `test_exported_xml_passes_xsd()` -- export a spec, validate the output against XSD

D. **CLI integration tests:**
- `test_cli_export_creates_xml()` -- write YAML spec to tmp, run `dab export`, verify XML output exists
- `test_cli_export_spec_not_found()` -- exit code 1 and error message
- `test_cli_export_warns_extensions()` -- YAML spec with staging_mappings, no --force, exit 1 with warning
- `test_cli_export_force_succeeds()` -- same spec with --force, exit 0
- `test_cli_export_no_overwrite()` -- output exists without --overwrite, exit 1
- `test_cli_export_with_overwrite()` -- output exists with --overwrite, exit 0

For test specs with staging_mappings, create them programmatically:
```python
spec_with_extensions = Spec(
    anchors=[Anchor(
        mnemonic="OR", descriptor="Order", identity="int",
        attributes=[Attribute(mnemonic="NAM", descriptor="Name", dataRange="varchar(50)")],
        staging_mappings=[StagingMapping(
            system="erp", tenant="acme", table="stg_orders",
            natural_key_columns=["order_id"], columns=[], column_mappings={}
        )]
    )]
)
```

Use `typer.testing.CliRunner` for CLI tests, same pattern as existing tests.

**Step 3: Create `tests/test_xml_roundtrip.py`.**

Test categories:

A. **Round-trip utility tests:**
- `test_canonicalize_normalizes_attribute_order()` -- two XML strings with different attribute orders canonicalize to same bytes
- `test_canonicalize_normalizes_whitespace()` -- indented vs compact XML canonicalize to same bytes
- `test_assert_roundtrip_equivalent_passes()` -- semantically equivalent XML passes
- `test_assert_roundtrip_equivalent_fails()` -- different XML raises AssertionError

B. **Full round-trip tests (XML -> YAML -> XML):**
- `test_roundtrip_simple_anchor()` -- single anchor with attributes round-trips
- `test_roundtrip_with_knots()` -- knot references preserved
- `test_roundtrip_with_ties()` -- ties with roles preserved
- `test_roundtrip_with_nexus()` -- nexus with roles and attributes preserved
- `test_roundtrip_example_xml()` -- `.references/anchor/example.xml` round-trips (THE key test for INTOP-04). Import example.xml -> Spec -> export XML -> canonicalize both -> compare.

NOTE on example.xml round-trip: The example.xml has some quirks:
1. No namespace -- our export adds namespace. Strip namespace from both before C14N comparison.
2. No XML declaration -- our export adds one. Compare canonical forms only.
3. `chronicle="1"` on one attribute -- this may not survive round-trip if our models don't capture it. If this causes round-trip failure, document it as a known limitation (non-standard attribute not in anchor.xsd).
4. Element ordering -- XML round-trip may reorder elements (knots first, then anchors, etc.). C14N does NOT sort child elements (only attributes). If element order differs, use a custom comparison that sorts elements by type+mnemonic before comparison.

For the round-trip comparison, implement a custom equivalence check that:
1. Strips namespace from both
2. Sorts child elements deterministically (by tag, then by mnemonic attribute if present)
3. Canonicalizes both
4. Compares canonical bytes

OR: Compare at the Spec level instead of XML level -- import original XML to Spec A, export Spec A to XML, import that XML to Spec B, compare Spec A == Spec B. This avoids XML-level comparison entirely and is more robust.

RECOMMENDED: Do BOTH:
- Spec-level round-trip: `import(xml) == import(export(import(xml)))` -- Pydantic model equality
- XML-level round-trip: canonical comparison with sorted elements (best-effort)
  </action>
  <verify>
Run `make check` -- all tests must pass (lint + type + test). Run `pytest tests/test_xml_export.py tests/test_xml_roundtrip.py -v` to verify new tests. Run end-to-end: `architect dab import .references/anchor/example.xml -o /tmp/test.yaml && architect dab export /tmp/test.yaml -o /tmp/roundtrip.xml --force` to verify full pipeline.
  </verify>
  <done>
`architect dab export spec.yaml` produces valid Anchor XML with XSD validation. Extensions are warned about and require --force. Round-trip tests pass for simple specs and the reference example.xml. All tests pass including lint and type checks.
  </done>
</task>

</tasks>

<verification>
1. `make check` passes (lint + type + test)
2. `architect dab export` works end-to-end with --force for specs with extensions
3. Export without extensions does not require --force
4. Exported XML passes XSD validation against anchor.xsd
5. Example.xml round-trips: import -> export -> import produces equivalent Spec
6. `pytest tests/test_xml_export.py tests/test_xml_roundtrip.py -v` shows all tests passing
7. CLI properly warns about extension data loss with yellow output
</verification>

<success_criteria>
- `export_spec_to_xml()` produces valid XML with namespace and XML declaration
- `check_yaml_extensions()` detects staging_mappings and staging_column
- Export raises ValueError without --force when extensions present
- `validate_xml_against_xsd()` validates against anchor.xsd
- `canonicalize_xml()` normalizes XML for comparison
- Round-trip test passes: XML -> import -> export -> XML is semantically equivalent
- `architect dab export` CLI command works end-to-end
- All tests pass, lint clean, types clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-xml-interoperability/09-02-SUMMARY.md`
</output>
