---
phase: 09-xml-interoperability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/data_architect/xml_interop/__init__.py
  - src/data_architect/xml_interop/models.py
  - src/data_architect/xml_interop/import_xml.py
  - src/data_architect/cli.py
  - tests/test_xml_import.py
autonomous: true

must_haves:
  truths:
    - "An Anchor Modeler XML file (with or without namespace) can be parsed into pydantic-xml models"
    - "XML models convert losslessly to existing YAML Pydantic models (Spec, Anchor, Attribute, Knot, Tie, Nexus, Role, Key, Identifier)"
    - "Running `architect dab import model.xml` produces a valid YAML spec file preserving all anchor.xsd elements"
    - "The official example.xml from .references/anchor/example.xml imports successfully with all 7 knots, 4 anchors, 1 nexus, 7 ties preserved"
  artifacts:
    - path: "src/data_architect/xml_interop/__init__.py"
      provides: "Public API for xml_interop module"
      exports: ["import_xml_to_spec", "import_xml_string_to_spec"]
    - path: "src/data_architect/xml_interop/models.py"
      provides: "BaseXmlModel classes for all anchor.xsd elements"
      contains: "class SchemaXML"
    - path: "src/data_architect/xml_interop/import_xml.py"
      provides: "XML to YAML Spec conversion functions"
      exports: ["import_xml_to_spec", "import_xml_string_to_spec"]
    - path: "tests/test_xml_import.py"
      provides: "Import tests including round-trip with example.xml"
      min_lines: 80
  key_links:
    - from: "src/data_architect/xml_interop/models.py"
      to: "src/data_architect/models/spec.py"
      via: "to_yaml_model() methods on each XML model class"
      pattern: "def to_yaml_model"
    - from: "src/data_architect/xml_interop/import_xml.py"
      to: "src/data_architect/xml_interop/models.py"
      via: "SchemaXML.from_xml() parsing"
      pattern: "SchemaXML\\.from_xml"
    - from: "src/data_architect/cli.py"
      to: "src/data_architect/xml_interop/import_xml.py"
      via: "dab import command calling import_xml_to_spec"
      pattern: "import_xml_to_spec"
---

<objective>
Import official Anchor Modeler XML into YAML specs (INTOP-01).

Purpose: Users who have existing Anchor Modeler XML files (from the official Anchor Modeler tool) can convert them to the YAML superset format used by this tool, preserving all anchor.xsd elements losslessly.

Output: `xml_interop` module with XML models (pydantic-xml), import function, CLI `dab import` command, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-xml-interoperability/09-RESEARCH.md
@.references/anchor/anchor.xsd
@.references/anchor/example.xml
@src/data_architect/models/common.py
@src/data_architect/models/spec.py
@src/data_architect/models/anchor.py
@src/data_architect/models/knot.py
@src/data_architect/models/tie.py
@src/data_architect/models/staging.py
@src/data_architect/cli.py
@src/data_architect/validation/loader.py
@src/data_architect/dab_init.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create XML models with import function</name>
  <files>
    pyproject.toml
    src/data_architect/xml_interop/__init__.py
    src/data_architect/xml_interop/models.py
    src/data_architect/xml_interop/import_xml.py
  </files>
  <action>
**Step 1: Install pydantic-xml and lxml.**

Run `uv add pydantic-xml[lxml] lxml` to add both as runtime dependencies in pyproject.toml. The `[lxml]` extra ensures pydantic-xml uses lxml as its backend (faster, namespace-aware).

**Step 2: Create `src/data_architect/xml_interop/models.py` with BaseXmlModel classes.**

Define pydantic-xml models that mirror the anchor.xsd structure. These are SEPARATE from the existing Pydantic BaseModel classes in `models/` -- they exist solely for XML serialization/deserialization.

CRITICAL namespace handling: The official example.xml does NOT use namespaces (`<schema>` not `<schema xmlns="...">`). Real Anchor Modeler exports MAY include the namespace `http://anchormodeling.com/schema`. The import function must handle BOTH cases.

Strategy: Define XML models WITHOUT a default namespace in nsmap, so pydantic-xml can parse un-namespaced XML. For namespaced XML, strip the namespace before parsing (simple lxml preprocessing).

Models to create (each must have `to_yaml_model()` method converting to the existing Pydantic model):

1. `KeyXML(BaseXmlModel, tag="key")` -- attributes: stop, route, of_ (name="of"), branch (default="1")
2. `IdentifierXML(BaseXmlModel, tag="identifier")` -- attributes: route
3. `MetadataXML(BaseXmlModel, tag="metadata")` -- use `anyAttribute` pattern: store as dict. Use lxml to capture arbitrary attributes since anchor.xsd allows `xs:anyAttribute` on metadata elements. Simplest: parse metadata element attributes into a dict.
4. `DescriptionXML(BaseXmlModel, tag="description")` -- text content
5. `LayoutXML(BaseXmlModel, tag="layout")` -- preserve as opaque string (serialize raw XML fragment)
6. `AttributeXML(BaseXmlModel, tag="attribute")` -- attributes: mnemonic, descriptor, knotRange (optional), dataRange (optional), timeRange (optional). Children: key (list), metadata (optional), layout (optional), description (optional)
7. `RoleXML(BaseXmlModel, tag="role")` -- attributes: role, type_ (name="type"), identifier (bool, default=False), coloring (optional). Children: key (list), metadata, layout, description
8. `AnchorXML(BaseXmlModel, tag="anchor")` -- attributes: mnemonic, descriptor, identity. Children: attribute (list), identifier (list), metadata, layout, description
9. `KnotXML(BaseXmlModel, tag="knot")` -- attributes: mnemonic, descriptor, identity, dataRange. Children: metadata, layout, description
10. `TieXML(BaseXmlModel, tag="tie")` -- attributes: timeRange (optional). Children: role (list), metadata, layout, description
11. `NexusXML(BaseXmlModel, tag="nexus")` -- attributes: mnemonic, descriptor, identity. Children: attribute (list), role (list), identifier (list), metadata, layout, description
12. `SchemaXML(BaseXmlModel, tag="schema")` -- Children: knot (list), anchor (list), nexus (list), tie (list), metadata, layout, description

Each model's `to_yaml_model()` method must:
- Map XML attributes to Pydantic model fields using the correct alias names (e.g., `knotRange` -> `knot_range` via alias)
- Pass child element lists through their own `to_yaml_model()` calls
- Use `model_validate()` with `by_alias=True` for field mapping (attributes use aliases like `knotRange`, `timeRange`, `dataRange`)
- Leave YAML-extension fields at their defaults (empty lists for staging_mappings, None for staging_column)

IMPORTANT: The `Attribute` model has a validator enforcing exactly one of knotRange/dataRange. The XML models must preserve this invariant when converting -- both must not be None and both must not be set.

For metadata handling: anchor.xsd defines metadata as allowing `xs:anyAttribute`. The simplest approach is to NOT use pydantic-xml for metadata parsing. Instead, handle metadata in the import function by extracting attributes from the lxml element directly into a `dict[str, str]`. In the XML models, make metadata optional and handle it during the conversion step using raw lxml access if pydantic-xml cannot represent arbitrary attributes.

Alternative simpler approach for metadata: Since pydantic-xml may struggle with `xs:anyAttribute`, consider parsing the entire XML with lxml first, then using a manual conversion approach. However, the RESEARCH recommends pydantic-xml, so try it first. If metadata is too complex, fall back to parsing metadata elements separately.

**Step 3: Create `src/data_architect/xml_interop/import_xml.py`.**

Two public functions:

```python
def import_xml_to_spec(xml_path: Path) -> Spec:
    """Import Anchor Modeler XML file to Spec."""

def import_xml_string_to_spec(xml_string: str) -> Spec:
    """Import Anchor Modeler XML string to Spec."""
```

Implementation:
1. Read the XML string (from file or directly)
2. Pre-process: if the XML has namespace `xmlns="http://anchormodeling.com/schema"`, strip it using lxml (or regex replacement) so the non-namespaced pydantic-xml models can parse it. This is simpler than maintaining dual namespace configs.
3. Parse with `SchemaXML.from_xml(xml_bytes)` where xml_bytes is the preprocessed XML encoded to bytes
4. Convert to YAML Spec via `schema_xml.to_yaml_model()` which calls `to_yaml_model()` recursively
5. Return the Spec

Handle the namespace stripping carefully:
```python
def _strip_namespace(xml_string: str) -> str:
    """Remove default namespace from XML for un-namespaced parsing."""
    # Use lxml to strip namespace properly
    from lxml import etree
    doc = etree.fromstring(xml_string.encode())
    for elem in doc.iter():
        if elem.tag and '}' in elem.tag:
            elem.tag = elem.tag.split('}', 1)[1]
    return etree.tostring(doc, encoding='unicode')
```

**Step 4: Create `src/data_architect/xml_interop/__init__.py`.**

Export the two public functions:
```python
from data_architect.xml_interop.import_xml import import_xml_to_spec, import_xml_string_to_spec
```

**Constraint from PROJECT.md:** "Pure functional style, no classes" -- EXCEPTION: pydantic-xml requires BaseXmlModel classes. The XML model classes are data containers (like existing Pydantic models in models/), not behavioral classes. This follows the same pattern as existing Anchor, Attribute, etc. models.
  </action>
  <verify>
Run `uv sync` to verify dependencies install. Run `python -c "from data_architect.xml_interop import import_xml_string_to_spec; print('OK')"` to verify imports work.
  </verify>
  <done>
pydantic-xml and lxml are installed. XML models exist for all anchor.xsd types. `import_xml_string_to_spec()` can parse a simple XML string into a Spec object. `import_xml_to_spec()` reads from a file path.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI import command and comprehensive tests</name>
  <files>
    src/data_architect/cli.py
    tests/test_xml_import.py
  </files>
  <action>
**Step 1: Add `dab import` command to `src/data_architect/cli.py`.**

Add the import at the top of cli.py:
```python
from data_architect.xml_interop import import_xml_to_spec
```

Add the command to `dab_app`:
```python
@dab_app.command(name="import")
def dab_import(
    xml_path: Path = typer.Argument(..., help="Path to Anchor Modeler XML file"),
    output: Path = typer.Option(
        Path("spec.yaml"),
        "--output", "-o",
        help="Output YAML spec file",
    ),
    overwrite: bool = typer.Option(
        False,
        "--overwrite",
        help="Overwrite existing YAML file",
    ),
) -> None:
```

Implementation flow:
1. Validate xml_path exists, exit(1) with red error if not
2. Check output exists and not --overwrite, exit(1) with red error if exists
3. Call `import_xml_to_spec(xml_path)` -- catch exceptions, print red error, exit(1)
4. Serialize Spec to YAML using ruamel.yaml (same approach as dab_init.py but with model data). Use `spec.model_dump(by_name=True, exclude_none=True)` to get a dict, then use `ruamel.yaml.YAML().dump()` to serialize. IMPORTANT: Use `by_name=True` (not `by_alias`) to get Python field names, BUT the YAML format uses aliases (knotRange, dataRange, timeRange, etc.) so use `by_alias=True` instead to match the YAML spec format that the loader expects.

Actually -- check how the existing YAML spec files are structured. The validation loader uses `Spec.model_validate(raw_data)` which works with alias names (knotRange, dataRange). So the YAML output should use alias names. Use `spec.model_dump(by_alias=True, exclude_none=True, exclude_defaults=True)` to produce a clean dict, then serialize with ruamel.yaml.

5. Write YAML to output file, creating parent directories
6. Print green success: checkmark + "Imported {xml_path} -> {output}"

For YAML serialization, create a helper function `serialize_spec_to_yaml(spec: Spec) -> str` in the import_xml module (or a shared location). This function:
- Calls `spec.model_dump(by_alias=True, exclude_none=True)`
- For list fields that are empty, exclude them (cleaner YAML)
- Serializes with `ruamel.yaml.YAML()` to a StringIO, returns the string
- Ensure list keys use singular alias names: `anchor` not `anchors`, `knot` not `knots`, `tie` not `ties`, `nexus` not `nexuses`, `role` not `roles`, `attribute` not `attributes` -- this should happen automatically with `by_alias=True` since the model fields have alias="anchor", etc.

**Step 2: Create `tests/test_xml_import.py` with comprehensive tests.**

Test categories:

A. **Unit tests for XML model parsing:**
- `test_parse_simple_anchor_xml()` -- single anchor with mnemonic, descriptor, identity
- `test_parse_anchor_with_attributes()` -- anchor with 2 attributes (one dataRange, one knotRange + timeRange)
- `test_parse_knot_xml()` -- knot with all required fields
- `test_parse_tie_xml()` -- tie with 2+ roles
- `test_parse_nexus_xml()` -- nexus with roles, attributes, identifiers
- `test_parse_role_with_keys()` -- role containing key children
- `test_parse_attribute_with_metadata()` -- attribute containing metadata element

B. **Integration tests for full import:**
- `test_import_minimal_xml()` -- schema with one anchor, one attribute
- `test_import_example_xml()` -- parse `.references/anchor/example.xml`, verify counts: 7 knots, 4 anchors (PN, ST, AC, PR), 1 nexus (EV), 7 ties. Verify specific attributes: ST has 4 attributes, AC has 3 attributes. Verify nexus EV has 3 roles and 3 attributes.
- `test_import_namespaced_xml()` -- schema with `xmlns="http://anchormodeling.com/schema"`, verify parsing works
- `test_import_preserves_key_elements()` -- verify Key(stop, route, of, branch) round-trips correctly
- `test_import_preserves_identifiers()` -- verify Identifier(route) preserved on anchors/nexuses

C. **CLI integration tests:**
- `test_cli_import_creates_yaml()` -- write XML to tmp file, run `dab import`, verify YAML output exists and is valid
- `test_cli_import_file_not_found()` -- verify exit code 1 and error message
- `test_cli_import_no_overwrite()` -- verify exit code 1 when output exists without --overwrite
- `test_cli_import_with_overwrite()` -- verify --overwrite works

D. **Edge cases:**
- `test_import_empty_schema()` -- `<schema/>` produces Spec with empty lists
- `test_import_anchor_no_attributes()` -- anchor with no child elements

Use pytest fixtures for common XML strings. Use `tmp_path` fixture for file operations. For CLI tests, use `typer.testing.CliRunner` (same pattern as existing test_cli.py).

For the example.xml test, read from `.references/anchor/example.xml` using `Path(__file__).parent.parent / ".references" / "anchor" / "example.xml"` or configure as a fixture. NOTE: example.xml has no namespace declaration and no XML declaration -- it's bare XML. Also note it has `chronicle="1"` on one attribute (EV.DAT) which is NOT in anchor.xsd and not in our models -- the import should handle unknown attributes gracefully (ignore or warn, not crash).
  </action>
  <verify>
Run `make check` (lint + type + test). All existing tests must still pass. New tests in test_xml_import.py must pass. Specifically: `pytest tests/test_xml_import.py -v` should show all tests passing. Run `architect dab import .references/anchor/example.xml -o /tmp/test_import.yaml && cat /tmp/test_import.yaml` to verify end-to-end import produces valid YAML.
  </verify>
  <done>
`architect dab import model.xml` converts XML to YAML spec. The example.xml imports with all 7 knots, 4 anchors, 1 nexus, 7 ties preserved. CLI handles errors (file not found, existing output). All tests pass including lint and type checks.
  </done>
</task>

</tasks>

<verification>
1. `uv sync` installs cleanly with pydantic-xml and lxml
2. `make check` passes (lint + type + test)
3. `architect dab import .references/anchor/example.xml -o /tmp/test.yaml` produces valid YAML
4. The output YAML can be loaded back: `python -c "from data_architect.validation.loader import validate_spec; r = validate_spec(Path('/tmp/test.yaml')); print(r.is_valid, len(r.errors))"`
5. `pytest tests/test_xml_import.py -v` shows all import tests passing
</verification>

<success_criteria>
- pydantic-xml and lxml are project dependencies
- XML model classes exist for all anchor.xsd element types (schema, anchor, attribute, knot, tie, nexus, role, key, identifier)
- `import_xml_to_spec(path)` and `import_xml_string_to_spec(string)` produce valid Spec objects
- `architect dab import` CLI command works end-to-end
- .references/anchor/example.xml imports with correct element counts
- Both namespaced and un-namespaced XML are handled
- All tests pass, lint clean, types clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-xml-interoperability/09-01-SUMMARY.md`
</output>
