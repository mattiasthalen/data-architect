---
phase: 05-pre-commit-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - .pre-commit-config.yaml
  - Makefile
  - scripts/hooks/pre-commit
  - scripts/hooks/commit-msg
autonomous: true

must_haves:
  truths:
    - "Running `make bootstrap` installs pre-commit hooks automatically"
    - "Committing code triggers `make check` via pre-commit framework"
    - "Committing with invalid message format is rejected with helpful error"
    - "Legacy scripts/hooks/ directory does not exist in repository"
  artifacts:
    - path: ".pre-commit-config.yaml"
      provides: "Pre-commit framework configuration"
      contains: "make check"
    - path: "pyproject.toml"
      provides: "pre-commit in dev dependencies"
      contains: "pre-commit"
    - path: "Makefile"
      provides: "Updated bootstrap target using pre-commit install"
      contains: "pre-commit install"
  key_links:
    - from: "Makefile"
      to: ".pre-commit-config.yaml"
      via: "uv run pre-commit install reads config"
      pattern: "uv run pre-commit install"
    - from: ".pre-commit-config.yaml"
      to: "Makefile"
      via: "make-check hook calls make check"
      pattern: "entry: make check"
    - from: ".pre-commit-config.yaml"
      to: "compilerla/conventional-pre-commit"
      via: "commit-msg hook delegates to external repo"
      pattern: "conventional-pre-commit"
---

<objective>
Migrate from legacy bash git hooks to the pre-commit framework. Replace manual hook script copying with declarative YAML configuration, add conventional commit validation via a maintained hook, and remove the legacy scripts/hooks/ directory.

Purpose: Standardize git hook management using the pre-commit framework -- declarative config, automatic installation, maintained conventional commit validation instead of hand-rolled regex.
Output: Working pre-commit framework with make check hook and conventional commit validation, legacy hooks removed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-pre-commit-framework/05-RESEARCH.md
@Makefile
@pyproject.toml
@scripts/hooks/pre-commit
@scripts/hooks/commit-msg
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pre-commit dependency and create .pre-commit-config.yaml</name>
  <files>pyproject.toml, .pre-commit-config.yaml</files>
  <action>
1. Add pre-commit to dev dependencies:
   Run `uv add --dev pre-commit` -- this updates pyproject.toml and uv.lock automatically.

2. Create `.pre-commit-config.yaml` in project root with this exact content:

```yaml
default_install_hook_types:
  - pre-commit
  - commit-msg

repos:
  - repo: local
    hooks:
      - id: make-check
        name: Run make check (lint + type + test)
        entry: make check
        language: system
        pass_filenames: false
        always_run: true
        verbose: true

  - repo: https://github.com/compilerla/conventional-pre-commit
    rev: v4.1.0
    hooks:
      - id: conventional-pre-commit
        stages: [commit-msg]
```

Key decisions and WHY:
- `language: system` (not `language: python`) -- make check needs the project environment, not an isolated one.
- `pass_filenames: false` -- Make discovers files itself; passing filenames causes "unknown target" errors.
- `always_run: true` -- make check should run on every commit regardless of which files changed.
- `verbose: true` -- show Make output so developers see lint/type/test results.
- `default_install_hook_types: [pre-commit, commit-msg]` -- single `pre-commit install` installs both hook types.
- Use the latest stable rev for conventional-pre-commit. Check `https://github.com/compilerla/conventional-pre-commit/releases` -- if v4.1.0 is not available, use the latest v3.x (v3.6.0 or similar). Run `uv run pre-commit autoupdate` after initial creation to pin the latest rev automatically.

3. After creating the config, run `uv run pre-commit autoupdate` to ensure the conventional-pre-commit rev is pinned to the actual latest release.
  </action>
  <verify>
- `grep "pre-commit" pyproject.toml` shows pre-commit in dev dependencies
- `.pre-commit-config.yaml` exists and contains `make-check` hook and `conventional-pre-commit` hook
- `uv run pre-commit --version` runs successfully
  </verify>
  <done>pyproject.toml has pre-commit as dev dependency, .pre-commit-config.yaml exists with local make-check hook (language: system, pass_filenames: false, always_run: true) and conventional-pre-commit for commit-msg stage, default_install_hook_types includes both pre-commit and commit-msg</done>
</task>

<task type="auto">
  <name>Task 2: Update Makefile bootstrap and remove legacy hooks</name>
  <files>Makefile, scripts/hooks/pre-commit, scripts/hooks/commit-msg</files>
  <action>
1. Update the `bootstrap` target in `Makefile` to replace manual hook copying with pre-commit install:

Replace the current bootstrap target:
```makefile
.PHONY: bootstrap
bootstrap:  ## Install deps + git hooks
	uv sync --dev
	@echo "Installing git hooks..."
	@cp scripts/hooks/pre-commit .git/hooks/pre-commit
	@cp scripts/hooks/commit-msg .git/hooks/commit-msg
	@chmod +x .git/hooks/pre-commit .git/hooks/commit-msg
	@echo "Done! Git hooks installed."
```

With:
```makefile
.PHONY: bootstrap
bootstrap:  ## Install deps + git hooks
	uv sync --dev
	@echo "Installing pre-commit hooks..."
	uv run pre-commit install
	@echo "Done! Git hooks installed via pre-commit framework."
```

Do NOT change any other Makefile targets -- only `bootstrap`.

2. Remove the legacy hooks directory entirely:
   Run `rm -rf scripts/hooks/`
   Then check if `scripts/` directory is now empty. If it is empty, remove `scripts/` too with `rmdir scripts/` (or `rm -rf scripts/` if it is empty).

3. Stage the removal for git: `git rm -r scripts/hooks/`
   (Use `git rm` instead of plain `rm` so git tracks the deletion.)
  </action>
  <verify>
- `make bootstrap` runs successfully (installs deps and pre-commit hooks)
- `ls .git/hooks/pre-commit` exists and is a pre-commit framework script (not the old bash script)
- `ls .git/hooks/commit-msg` exists and is a pre-commit framework script
- `ls scripts/hooks/ 2>/dev/null` returns nothing (directory removed)
- `grep -c "cp scripts/hooks" Makefile` returns 0 (no legacy references)
  </verify>
  <done>Makefile bootstrap target uses `uv run pre-commit install` instead of manual hook copying, scripts/hooks/ directory is deleted from the repository, no references to legacy hooks remain in Makefile</done>
</task>

<task type="auto">
  <name>Task 3: Validate end-to-end hook behavior</name>
  <files></files>
  <action>
1. Run `make bootstrap` from scratch to verify the full setup flow works.

2. Verify pre-commit hook works by running: `uv run pre-commit run --all-files`
   This should execute `make check` (lint + type + test) and show output. All checks should pass.

3. Verify commit-msg hook works by testing with an invalid message:
   Create a temp file, stage it, attempt commit with bad message:
   ```bash
   echo "test" > /tmp/test-hook.txt
   cp /tmp/test-hook.txt test-hook-temp.txt
   git add test-hook-temp.txt
   git commit -m "bad message" 2>&1 || true
   ```
   This should FAIL with a conventional commit format error.
   Clean up: `git reset HEAD test-hook-temp.txt && rm -f test-hook-temp.txt`

4. Verify valid commit format works by running:
   `echo "test: valid format" | uv run pre-commit run conventional-pre-commit --commit-msg-filename /dev/stdin 2>&1 || true`
   (Note: exact invocation may vary; the key test is that `make bootstrap && uv run pre-commit run --all-files` passes.)

5. Run `make check` directly to confirm it still works independently of pre-commit.

If any step fails, diagnose and fix. The goal is that ALL requirements (HOOK-01 through HOOK-05) are met.
  </action>
  <verify>
- `make bootstrap` completes without errors
- `uv run pre-commit run --all-files` passes (make check runs via pre-commit)
- `make check` still works independently
- `ls scripts/hooks/ 2>/dev/null` returns empty (legacy hooks gone)
- `.git/hooks/pre-commit` contains pre-commit framework shim (not old bash script)
- `.git/hooks/commit-msg` contains pre-commit framework shim
  </verify>
  <done>Full pre-commit framework is operational: make bootstrap installs hooks, make check runs via pre-commit on every commit, conventional commit messages are validated on commit-msg stage, legacy scripts/hooks/ directory is removed, make check still works independently</done>
</task>

</tasks>

<verification>
Requirements coverage check:
- HOOK-01: Pre-commit framework installed via `make bootstrap` -- Task 1 (dependency) + Task 2 (bootstrap target)
- HOOK-02: `.pre-commit-config.yaml` exists with local hook running `make check` -- Task 1
- HOOK-03: Commit-msg hook validates conventional commit format -- Task 1 (conventional-pre-commit config)
- HOOK-04: Legacy `scripts/hooks/` bash scripts removed -- Task 2
- HOOK-05: `make bootstrap` updated to use `pre-commit install` -- Task 2

End-to-end validation:
1. `make bootstrap` completes successfully
2. `uv run pre-commit run --all-files` executes make check and passes
3. Invalid commit messages are rejected by conventional-pre-commit hook
4. `ls scripts/hooks/` fails (directory gone)
5. `make check` works independently (no regression)
</verification>

<success_criteria>
1. `.pre-commit-config.yaml` exists with make-check hook and conventional-pre-commit hook
2. `pyproject.toml` lists pre-commit in dev dependencies
3. `make bootstrap` installs pre-commit hooks (not manual copy)
4. `uv run pre-commit run --all-files` passes
5. `scripts/hooks/` directory does not exist
6. All existing tests pass (`make check`)
</success_criteria>

<output>
After completion, create `.planning/phases/05-pre-commit-framework/05-01-SUMMARY.md`
</output>
