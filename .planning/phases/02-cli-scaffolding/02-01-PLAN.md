---
phase: 02-cli-scaffolding
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/data_architect/scaffold.py
  - src/data_architect/templates.py
  - tests/test_scaffold.py
autonomous: true

must_haves:
  truths:
    - "Scaffold function returns list of actions (created, skipped, would-create) for every expected file"
    - "Existing files are skipped by default, overwritten when force=True"
    - "Dry-run mode returns would-create actions without writing to disk"
    - "Target directory is used as root for all file paths"
    - "All expected files are included in the manifest (6 agents, skills, AGENTS.md, opencode.json)"
  artifacts:
    - path: "src/data_architect/scaffold.py"
      provides: "Pure scaffold engine — scaffold() function and result types"
      exports: ["scaffold", "ScaffoldResult", "ScaffoldAction", "MANIFEST"]
    - path: "src/data_architect/templates.py"
      provides: "File content definitions for all scaffolded files"
      exports: ["TEMPLATES"]
    - path: "tests/test_scaffold.py"
      provides: "TDD tests for scaffold engine"
      min_lines: 80
  key_links:
    - from: "src/data_architect/scaffold.py"
      to: "src/data_architect/templates.py"
      via: "import TEMPLATES"
      pattern: "from data_architect\\.templates import"
---

<objective>
Build the pure-functional scaffold engine via TDD — the core logic that determines which files to create, detects conflicts, and supports dry-run mode.

Purpose: Separate testable business logic from I/O and CLI concerns. Every behavior of `architect init` flows through this engine.
Output: `scaffold.py` with pure functions, `templates.py` with file manifest, comprehensive tests proving all behaviors.
</objective>

<execution_context>
@./.Claude/get-shit-done/workflows/execute-plan.md
@./.Claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-scaffolding/02-CONTEXT.md
@src/data_architect/__init__.py
@src/data_architect/cli.py
@pyproject.toml
@tests/test_cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define result types, file manifest, and write failing tests</name>
  <files>src/data_architect/scaffold.py, src/data_architect/templates.py, tests/test_scaffold.py</files>
  <action>
**Result types in `scaffold.py`** (use dataclasses, frozen=True per pure-functional style):
- `ScaffoldAction` enum: `CREATED`, `SKIPPED`, `WOULD_CREATE`
- `ScaffoldResult` dataclass: `path: str`, `action: ScaffoldAction`, `reason: str`

**File manifest in `templates.py`**:
- `TEMPLATES: dict[str, str]` mapping relative paths to minimal stub content
- Full file list:
  - `.opencode/agents/data-architect.md` — valid YAML frontmatter (description, model) + TODO body
  - `.opencode/agents/data-engineer.md` — same pattern
  - `.opencode/agents/analytics-engineer.md` — same pattern
  - `.opencode/agents/system-analyst.md` — same pattern
  - `.opencode/agents/business-analyst.md` — same pattern
  - `.opencode/agents/veteran-reviewer.md` — same pattern
  - `.opencode/skills/da-start/SKILL.md` — minimal skill stub
  - `AGENTS.md` — minimal shared context stub
  - `opencode.json` — minimal valid config JSON
- Each stub should have valid structure but minimal content (e.g., agent files: valid YAML frontmatter with `description` and `model` fields, body is `<!-- TODO: Full prompt in Phase 3 -->`)

**Tests in `tests/test_scaffold.py`** (write ALL tests before any scaffold logic):
- `test_scaffold_creates_all_files_in_empty_dir` — scaffold() in tmp dir returns CREATED for every file in MANIFEST
- `test_scaffold_files_exist_on_disk` — after scaffold(), every file exists on disk with expected content
- `test_scaffold_skips_existing_files` — pre-create one file, scaffold() returns SKIPPED for it, CREATED for rest
- `test_scaffold_skipped_file_not_overwritten` — pre-create file with custom content, scaffold(), custom content preserved
- `test_scaffold_force_overwrites_existing` — pre-create file, scaffold(force=True), file has template content, result is CREATED
- `test_scaffold_dry_run_no_files_written` — scaffold(dry_run=True), returns WOULD_CREATE for all, no files on disk
- `test_scaffold_target_dir` — scaffold(target_dir=custom_path), files created under custom_path
- `test_scaffold_creates_subdirectories` — scaffold() creates `.opencode/agents/` and `.opencode/skills/da-start/` directories
- `test_manifest_has_expected_file_count` — TEMPLATES has exactly 9 entries
- `test_all_agent_files_have_yaml_frontmatter` — each agent .md file starts with `---`

Use `tmp_path` pytest fixture for all filesystem tests. Import `scaffold` function and `TEMPLATES` even though they don't exist yet — tests must fail with ImportError or AssertionError.

Run tests: `uv run pytest tests/test_scaffold.py` — expect failures (RED).
  </action>
  <verify>`uv run pytest tests/test_scaffold.py` runs and all tests FAIL (not with SyntaxError — with ImportError or AssertionError)</verify>
  <done>test_scaffold.py has 10+ tests, all failing. scaffold.py has type stubs only (ScaffoldResult, ScaffoldAction, empty scaffold function). templates.py has TEMPLATES dict with 9 entries.</done>
</task>

<task type="auto">
  <name>Task 2: Implement scaffold engine to pass all tests</name>
  <files>src/data_architect/scaffold.py</files>
  <action>
Implement `scaffold()` function in `scaffold.py`:

```python
def scaffold(
    target_dir: Path,
    *,
    force: bool = False,
    dry_run: bool = False,
) -> list[ScaffoldResult]:
```

Logic (pure-functional — the function takes a Path and returns results, side effects are file writes):
1. Iterate over TEMPLATES items (relative_path, content)
2. Resolve full path: `target_dir / relative_path`
3. If dry_run: append `ScaffoldResult(path, WOULD_CREATE, "Dry run")`
4. Elif file exists and not force: append `ScaffoldResult(path, SKIPPED, "Already exists")`
5. Else: create parent directories, write file, append `ScaffoldResult(path, CREATED, "Created")`
6. Return list of all results

Note: This function does perform I/O (file writes). The "pure" aspect is that it has no hidden state — all inputs are explicit parameters, all outputs are in the return value. The I/O is the intended side effect.

Keep the function focused — no printing, no color, no formatting. That's the CLI layer's job (Plan 02).

Run `uv run pytest tests/test_scaffold.py` — all tests must pass (GREEN).
Run `make check` — lint, type, and all tests must pass.
  </action>
  <verify>`uv run pytest tests/test_scaffold.py` — all pass. `make check` — all pass.</verify>
  <done>All scaffold tests pass. scaffold() handles create, skip, force-overwrite, dry-run, and target directory. `make check` is green.</done>
</task>

</tasks>

<verification>
- `uv run pytest tests/test_scaffold.py -v` shows all tests passing
- `make check` passes (lint + type + test)
- `from data_architect.scaffold import scaffold, ScaffoldResult, ScaffoldAction` works
- `from data_architect.templates import TEMPLATES` works and has 9 entries
</verification>

<success_criteria>
- Pure scaffold function handles all five behaviors: create, skip, force, dry-run, target-dir
- 10+ tests cover every behavior and edge case
- Templates define all 9 files with valid minimal stub content
- All quality gates pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-scaffolding/02-01-SUMMARY.md`
</output>
