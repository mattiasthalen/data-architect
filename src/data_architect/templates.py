"""File content definitions for all scaffolded files."""

TEMPLATES: dict[str, str] = {
    ".opencode/agents/data-architect.md": (
        "---\n"
        "description: Entry point and design authority for data warehouse modeling\n"
        "model: anthropic:claude-sonnet-4-20250514\n"
        "---\n"
        "<!-- TODO: Full prompt in Phase 3 -->\n"
    ),
    ".opencode/agents/data-engineer.md": (
        "---\n"
        "description: Physical modeling specialist for performance and orchestration\n"
        "model: anthropic:claude-sonnet-4-20250514\n"
        "---\n"
        "<!-- TODO: Full prompt in Phase 3 -->\n"
    ),
    ".opencode/agents/analytics-engineer.md": (
        "---\n"
        "description: DAR layer perspective on warehouse consumption\n"
        "model: anthropic:claude-sonnet-4-20250514\n"
        "---\n"
        "<!-- TODO: Full prompt in Phase 3 -->\n"
    ),
    ".opencode/agents/system-analyst.md": (
        "---\n"
        "description: Source system expert for technical data understanding\n"
        "model: anthropic:claude-sonnet-4-20250514\n"
        "---\n"
        "<!-- TODO: Full prompt in Phase 3 -->\n"
    ),
    ".opencode/agents/business-analyst.md": (
        "---\n"
        "description: Business domain expert for requirements and data meaning\n"
        "model: anthropic:claude-sonnet-4-20250514\n"
        "---\n"
        "<!-- TODO: Full prompt in Phase 3 -->\n"
    ),
    ".opencode/agents/veteran-reviewer.md": (
        "---\n"
        "description: Battle-scarred DW engineer who critiques for anti-patterns\n"
        "model: anthropic:claude-sonnet-4-20250514\n"
        "---\n"
        "<!-- TODO: Full prompt in Phase 3 -->\n"
    ),
    ".opencode/skills/da-start/SKILL.md": (
        "---\n"
        "description: Start a data warehouse design session\n"
        "---\n"
        "<!-- TODO: Full skill definition in Phase 3 -->\n"
    ),
    "AGENTS.md": (
        "# Shared Agent Context\n"
        "\n"
        "This document provides shared methodology context for all data warehouse modeling agents.\n"
        "\n"
        "## ADSS Three-Layer Architecture\n"
        "\n"
        "ADSS (Agile Data Storage Solution) organizes the data warehouse into three distinct layers, each with a specific purpose and transformation responsibility:\n"
        "\n"
        "### DAS: Data According to System\n"
        "\n"
        "The DAS layer captures raw data from source systems with minimal transformation. Its purpose is to preserve source system semantics, maintain audit trails, and decouple downstream layers from source system changes. Data is ingested as-is, with only technical transformations (data type conversions, encoding normalization) applied. Business logic and interpretation are explicitly excluded from this layer.\n"
        "\n"
        "### DAB: Data According to Business\n"
        "\n"
        "The DAB layer is where business meaning is imposed on the data through Anchor Modeling. This is the debate layer — where System Analysts and Business Analysts argue about entity identity, attribute classification, and relationship semantics. The DAB layer uses highly normalized Anchor Modeling techniques to create a time-variant, agile representation of business reality. All schema evolution is non-destructive (additive only), enabling the model to adapt to changing business requirements without breaking existing structures.\n"
        "\n"
        "### DAR: Data According to Requirements\n"
        "\n"
        "The DAR layer is the consumption layer, optimized for specific business questions and reporting needs. It uses Unified Star Schema (USS) patterns derived from the DAB layer — a single bridge table connecting all dimensions to facts, eliminating fan traps and chasm traps. The DAR layer is denormalized for query performance and tailored to actual consumption patterns.\n"
        "\n"
        "### Unidirectional Flow\n"
        "\n"
        "Data flows in one direction: DAS -> DAB -> DAR. Each layer decouples the next from upstream changes. Changes in source systems impact DAS, but DAB remains stable. Changes in business interpretation impact DAB, but DAR can be rebuilt from the stable DAB foundation. This isolation is the key to ADSS agility.\n"
        "\n"
        "## Anchor Modeling Core Concepts\n"
        "\n"
        "Anchor Modeling is the technique used in the DAB layer. It provides maximum agility through non-destructive schema evolution.\n"
        "\n"
        "### Anchor\n"
        "\n"
        "An anchor represents immutable entity identity. Once an entity is assigned an anchor ID, that ID never changes and never represents a different entity. Anchors have no attributes of their own — they are pure identity. Examples: `anchor__customer`, `anchor__order`, `anchor__product`.\n"
        "\n"
        "### Attribute\n"
        "\n"
        "An attribute is a historized property of an anchor. Each attribute is its own table, containing the anchor ID, the attribute value, and the time period during which that value was valid. This enables tracking how entity properties change over time without destroying historical data. Examples: `anchor__customer__name`, `anchor__order__order_date`, `anchor__product__price`.\n"
        "\n"
        "### Tie\n"
        "\n"
        "A tie represents a many-to-one relationship between two anchors. Ties are always directional and always many-to-one (never one-to-one or many-to-many). Ties can be historized (tracking when the relationship changed) or static. Example: `tie__order__placed_by__customer` means many orders are placed by one customer.\n"
        "\n"
        "### Knot\n"
        "\n"
        "A knot is shared reference data — lookup values used across multiple anchors. Instead of duplicating reference data in every attribute table, knots provide a single source of truth for things like currency codes, country codes, or status values. Examples: `knot__currency`, `knot__country`, `knot__order_status`.\n"
        "\n"
        "### Nexus\n"
        "\n"
        "A nexus represents a many-to-many intersection between anchors. While ties handle many-to-one relationships, nexuses handle cases where multiple entities on both sides relate to each other (e.g., products on an order line). Examples: `nexus__order_line` (connecting order and product).\n"
        "\n"
        "### Non-Destructive Schema Evolution\n"
        "\n"
        "Anchor Modeling's key strength is additive-only schema evolution. Need a new attribute? Add a new attribute table. Need to historize something that was static? Add a new historized attribute table alongside the static one. Need to track a new relationship? Add a new tie table. Existing structures are never modified or deleted, ensuring historical queries continue to work and data is never destroyed.\n"
        "\n"
        "## CLP Stages Overview\n"
        "\n"
        "The DAB layer design process follows three stages:\n"
        "\n"
        "### Conceptual\n"
        "\n"
        "What entities exist? What is their business meaning? This stage identifies the anchors — the core business concepts that have independent identity. Questions asked: What are we modeling? What are the key business entities? What makes each entity unique from a business perspective?\n"
        "\n"
        "### Logical\n"
        "\n"
        "How do entities relate? How should properties be classified? This stage defines attributes (what properties does each anchor have?), ties (how do anchors relate to each other?), knots (what reference data is shared?), and nexuses (what many-to-many relationships exist?). This is where the System Analyst vs Business Analyst debate happens — arguing about tie direction, attribute classification, and relationship semantics.\n"
        "\n"
        "### Physical\n"
        "\n"
        "How should this be implemented for performance? This stage addresses indexing strategies, partitioning schemes, materialized views, and orchestration patterns. The Data Engineer leads this stage, translating the logical model into a performant physical implementation.\n"
        "\n"
        "Note: Detailed debate protocols for each stage are defined separately. This overview establishes the structure.\n"
        "\n"
        "## USS Basics\n"
        "\n"
        "Unified Star Schema (USS) is the pattern used in the DAR layer. Traditional star schemas can suffer from fan traps (multiple dimension tables creating cartesian products) and chasm traps (unrelated facts being incorrectly joined). USS solves this with a single bridge table that connects all dimensions to all facts, explicitly defining which dimension values are valid for which fact rows. This eliminates ambiguity and ensures query correctness.\n"
        "\n"
        "The USS pattern is derived mechanically from the DAB layer — anchors become dimensions, attributes populate dimension tables, and ties/nexuses inform the bridge table structure.\n"
        "\n"
        "## Naming Conventions\n"
        "\n"
        "All database objects MUST follow these conventions. These rules are non-negotiable.\n"
        "\n"
        "### Anchor\n"
        "\n"
        "```\n"
        "anchor__<entity>\n"
        "```\n"
        "\n"
        "Examples: `anchor__customer`, `anchor__order`, `anchor__product`\n"
        "\n"
        "### Attribute\n"
        "\n"
        "```\n"
        "anchor__<entity>__<attribute>\n"
        "```\n"
        "\n"
        "Examples: `anchor__customer__name`, `anchor__order__order_date`, `anchor__product__price`\n"
        "\n"
        "### Tie (always many-to-one)\n"
        "\n"
        "```\n"
        "tie__<from>__<verb>__<to>\n"
        "```\n"
        "\n"
        "Examples: `tie__order__placed_by__customer`, `tie__product__belongs_to__category`\n"
        "\n"
        'The "from" side is many, the "to" side is one. Read as: many orders are placed_by one customer.\n'
        "\n"
        "### Knot\n"
        "\n"
        "```\n"
        "knot__<name>\n"
        "```\n"
        "\n"
        "Examples: `knot__currency`, `knot__country`, `knot__order_status`\n"
        "\n"
        "### Nexus (many-to-many)\n"
        "\n"
        "```\n"
        "nexus__<name>\n"
        "```\n"
        "\n"
        "Examples: `nexus__order_line`, `nexus__product_bundle`\n"
        "\n"
        "### Rules\n"
        "\n"
        "1. **snake_case only** — no PascalCase, no camelCase\n"
        "2. **Double underscore `__` as separator** — single underscore within words (e.g., `order_date`), double underscore between components\n"
        "3. **NO mnemonics** — write `customer` not `cust`, `order` not `ord`, `product` not `prod`\n"
        "4. **Full readable names** — optimize for human understanding, not byte count\n"
        "\n"
        "## Team Interaction Rules\n"
        "\n"
        "### Agent Roles\n"
        "\n"
        "- **Data Architect**: Entry point and design authority. Orchestrates the debate, synthesizes recommendations, enforces methodology compliance and naming standards.\n"
        "- **System Analyst**: Source system expert. Advocates for technical fidelity to how data actually exists in source systems.\n"
        "- **Business Analyst**: Business domain expert. Advocates for how the business thinks about and uses the data.\n"
        "- **Data Engineer**: Physical modeling specialist. Focuses on performance, indexing, partitioning, and orchestration.\n"
        "- **Analytics Engineer**: Consumption perspective. Evaluates designs from the lens of how the DAR layer will be queried.\n"
        "- **Veteran Reviewer**: Methodology critic. Identifies anti-patterns and methodology violations in proposed designs.\n"
        "\n"
        "### Debate Expectations\n"
        "\n"
        "The System Analyst and Business Analyst are expected to argue. Their perspectives will often conflict — the System Analyst wants to preserve source system semantics, the Business Analyst wants to impose business meaning. This tension is productive. The Data Architect synthesizes both perspectives and recommends a resolution that respects both source reality and business needs.\n"
        "\n"
        "The Veteran Reviewer critiques the final design against Anchor Modeling methodology and common anti-patterns. Their role is to challenge assumptions and catch mistakes before they become production problems.\n"
        "\n"
        "### Escalation Path\n"
        "\n"
        "When the team cannot reach consensus, the dispute escalates to the user. The Data Architect presents:\n"
        "- The System Analyst's position and rationale\n"
        "- The Business Analyst's position and rationale\n"
        "- The Data Architect's synthesis and recommendation\n"
        "- The methodology constraints that apply\n"
        "\n"
        "The user makes the final decision. The user is the ultimate authority on all modeling decisions.\n"
        "\n"
        "---\n"
        "\n"
        "*This document is loaded into all agent contexts. It provides shared understanding of ADSS, Anchor Modeling, naming conventions, and team collaboration patterns.*\n"
    ),
    "opencode.json": (
        "{\n"
        '  "$schema": "https://opencode.ai/config.json",\n'
        '  "name": "data-architect",\n'
        '  "default_agent": "data-architect",\n'
        '  "agents": {\n'
        '    "data-architect": {\n'
        '      "mode": "primary"\n'
        "    }\n"
        "  },\n"
        '  "instructions": ["AGENTS.md"],\n'
        '  "autoupdate": true,\n'
        '  "_comment": "Model tier (budget/standard/high) will be configured by Data Architect agent on first /da:start interaction. Budget=fast+cheap, Standard=balanced, High=maximum quality."\n'
        "}\n"
    ),
    ".data-architect/specs/examples/anchor-example.yaml": (
        "# Example: Anchor with Attributes\n"
        "# This demonstrates the structure for defining an anchor and its attributes.\n"
        "\n"
        "# Anchor identity (immutable entity ID)\n"
        "anchor:\n"
        "  name: anchor__customer\n"
        "  description: A customer who purchases products or services from the business\n"
        "  \n"
        "  # Attributes are historized properties of the anchor\n"
        "  # Each attribute becomes its own table in the physical model\n"
        "  attributes:\n"
        "    - name: anchor__customer__name\n"
        "      description: Customer full name\n"
        "      data_type: string\n"
        "      historized: true  # Track changes over time\n"
        "      \n"
        "    - name: anchor__customer__email\n"
        "      description: Customer email address\n"
        "      data_type: string\n"
        "      historized: true  # Email can change\n"
        "      \n"
        "    - name: anchor__customer__date_of_birth\n"
        "      description: Customer date of birth\n"
        "      data_type: date\n"
        "      historized: false  # Birth date is immutable\n"
        "      \n"
        "    - name: anchor__customer__account_created_at\n"
        "      description: Timestamp when customer account was created\n"
        "      data_type: timestamp\n"
        "      historized: false  # Creation timestamp is immutable\n"
        "\n"
        "# Naming convention rules:\n"
        "# - anchor__<entity> for the anchor itself\n"
        "# - anchor__<entity>__<attribute> for each attribute\n"
        "# - snake_case only, double underscore __ as separator\n"
        "# - NO mnemonics (use 'customer' not 'cust')\n"
    ),
    ".data-architect/specs/examples/domain-example.yaml": (
        "# Example: E-Commerce Domain Model\n"
        "# This demonstrates how anchors, ties, and knots compose into a complete domain.\n"
        "\n"
        "domain:\n"
        "  name: e-commerce\n"
        "  description: Core e-commerce domain covering customers, orders, and products\n"
        "  \n"
        "  # Anchors represent business entities with immutable identity\n"
        "  anchors:\n"
        "    - name: anchor__customer\n"
        "      description: A customer who purchases from the business\n"
        "      attributes:\n"
        "        - name: anchor__customer__name\n"
        "          data_type: string\n"
        "          historized: true\n"
        "        - name: anchor__customer__email\n"
        "          data_type: string\n"
        "          historized: true\n"
        "          \n"
        "    - name: anchor__order\n"
        "      description: A customer order\n"
        "      attributes:\n"
        "        - name: anchor__order__order_date\n"
        "          data_type: timestamp\n"
        "          historized: false\n"
        "        - name: anchor__order__total_amount\n"
        "          data_type: decimal\n"
        "          historized: true  # Can be adjusted\n"
        "          \n"
        "    - name: anchor__product\n"
        "      description: A product available for purchase\n"
        "      attributes:\n"
        "        - name: anchor__product__name\n"
        "          data_type: string\n"
        "          historized: true\n"
        "        - name: anchor__product__price\n"
        "          data_type: decimal\n"
        "          historized: true  # Price changes over time\n"
        "  \n"
        "  # Ties represent many-to-one relationships between anchors\n"
        "  ties:\n"
        "    - name: tie__order__placed_by__customer\n"
        "      description: Many orders are placed by one customer\n"
        "      from_anchor: anchor__order\n"
        "      to_anchor: anchor__customer\n"
        "      historized: false  # Order ownership doesn't change\n"
        "      \n"
        "    - name: tie__product__belongs_to__category\n"
        "      description: Many products belong to one category\n"
        "      from_anchor: anchor__product\n"
        "      to_anchor: anchor__category\n"
        "      historized: true  # Product can be recategorized\n"
        "  \n"
        "  # Knots represent shared reference/lookup data\n"
        "  knots:\n"
        "    - name: knot__currency\n"
        "      description: Currency codes (USD, EUR, GBP, etc.)\n"
        "      data_type: string\n"
        "      values:\n"
        "        - USD\n"
        "        - EUR\n"
        "        - GBP\n"
        "        \n"
        "    - name: knot__order_status\n"
        "      description: Order status values\n"
        "      data_type: string\n"
        "      values:\n"
        "        - pending\n"
        "        - confirmed\n"
        "        - shipped\n"
        "        - delivered\n"
        "        - cancelled\n"
        "  \n"
        "  # Nexuses represent many-to-many relationships\n"
        "  nexuses:\n"
        "    - name: nexus__order_line\n"
        "      description: Many-to-many relationship between orders and products\n"
        "      anchors:\n"
        "        - anchor__order\n"
        "        - anchor__product\n"
        "      attributes:\n"
        "        - name: quantity\n"
        "          data_type: integer\n"
        "        - name: unit_price\n"
        "          data_type: decimal\n"
        "\n"
        "# Naming convention enforcement:\n"
        "# - All names use snake_case with double underscore __ separators\n"
        "# - No mnemonics: 'customer' not 'cust', 'order' not 'ord'\n"
        "# - Ties always many-to-one: tie__<from>__<verb>__<to>\n"
        '# - Read tie direction as: "many <from> <verb> one <to>"\n'
    ),
}
